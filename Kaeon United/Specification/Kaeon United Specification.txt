#[ Kaeon United Specification ]#

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE ]#

-
	ONE
-
	-
		Philosophy
	-
		-
			ONE is a system for organizing data.
		-
	-
		Principles
	-
		-
			Elements
		-
			-
				ONE stores data in elements.
				
				An element must contain a string of characters, and may act as a parent to other
				elements.
				
				The children of a given element must be arranged in a specific order relative to
				each other. No element may be the child of more than one element, and no loops may
				occur in the chain of parent-child connections.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 1 - ONE Conventions ]#

-
	ONE Conventions
-
	-
		Philosophy
	-
		-
			The ONE conventions are a set of principles regarding ONE that should be applied in any
			scenario where ONE is relevant.
		-
	-
		Principles
	-
		-
			Content
		-
			-
				The string contained by an element is referred to as its content.
			-
		-
			Scope
		-
			-
				Any element that may be accessed by trickling down through the child connections of
				another element are said to be in the latter element's scope.
			-
		-
			Default Element
		-
			-
				By default, an element will have an empty string as its content and will have no
				children.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 2 - ONE Language ]#

-
	ONE Language
-
	-
		Philosophy
	-
		-
			The ONE language is a syntax for encoding ONE elements.
			
			A unit of text written in the ONE language is referred to as a ONE document.
		-
	-
		Principles
	-
		-
			Syntax
		-
			-
				The ONE language requires three unique sequences of characters to be defined: the
				terminating sequence, the breaking sequence, and the nesting sequence. It is not
				permitted for the sequences to be defined such that there may be any instances
				where two or more sequences conflict at a given location.
				
				The ONE language is composed entirely of ONE element definitions. No characters are
				permitted outside of element definitions.
				
				An element definition begins with the terminating sequence, followed by the
				breaking sequence, followed by the nesting sequence. The nesting sequence may be
				followed by any sequence of characters as long as the breaking sequence does not
				occur within it. This sequence is referred to as the encoded sequence. The encoded
				sequence is followed by the breaking sequence, which must be followed either with
				the nesting sequence which continues the element definition, or by the terminating
				sequence which ends the element definition. If an element definition precedes
				another element definition, the final terminating sequence of the preceding element
				definition must be followed by the breaking sequence.
				
				Element definitions may be nested within one another. If an element definition is
				nested within another element definition, the child element definition must be
				placed directly after either its parent or after another element definition nested
				within the scope of its parent. For every terminating sequence that does not occur
				with an encoded sequence and for every nesting sequence which immediately precedes
				an encoded sequence within the element definition, one instance of the nesting
				sequence must be placed between the breaking sequence that precedes said sequence
				and said sequence for every level the element definition is nested.
			-
		-
			Semantics
		-
			-
				The encoded data will all reside within the scope of an element with no parent and
				an empty string as its content referred to as the document element.
				
				Every element definition with no parent will encode an element as a child of the
				document element. Every element definition with a parent will encode an element as
				a child of the element defined by its parent element definition.
				
				The content encoded into elements defined by element definitions will consist of
				the content of each encoded sequence within the respective element definition, each
				with the exception of the content of the last occurring encoded sequence within the
				respective element definition followed by an instance of the breaking sequence,
				concatenated in the order in which the respective encoded sequences occur within
				the respective element definition.
				
				The order in which elements defined by element definitions are arranged within
				their parent element shall correspond to the order in which the definitions that
				defined them are written.
			-
		-
			Encoding
		-
			-
				A ONE element can only be encoded as a ONE document if it has an empty string as
				its content. Said element will become the document element of the document.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 2 - ONE Language: 1 - Standard ONE Language ]#

-
	Standard ONE Language
-
	-
		Philosophy
	-
		-
			The standard variant of the ONE Language defines specific sequences of characters as
			the three required sequences of the ONE language.
		-
	-
		Principles
	-
		-
			Standard Sequences
		-
			-
				Terminating Sequence
			-
				-
					In the standard variant of the ONE Language, the terminating sequence is a
					dash.
				-
			-
				Breaking Sequence
			-
				-
					In the standard variant of the ONE Language, the breaking sequence is a new
					line.
				-
			-
				Nesting Sequence
			-
				-
					In the standard variant of the ONE Language, the nesting sequence is a tab.
				-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 2 - ONE Language: 2 - Reduced ONE Language ]#

-
	Reduced ONE Language
-
	-
		Philosophy
	-
		-
			The reduced ONE language is an alternate form of the ONE language where all instances
			of the terminating sequence except for those that occur within encoded sequences are
			omitted.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents ]#

-
	Kaeon Documents
-
	-
		Philosophy
	-
		-
			The Kaeon document format is a ONE document format that is used for formal documents.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				A Kaeon Document contains one element at the root level. The content of the element
				is the name of the concept.
				
				The first child of the element at the root contains the content "Philosophy". The
				first and only child of this element contains content giving an overview of the
				concept.
				
				The next child of the element shall only be present is the content of the child
				of the first child is not sufficient to establish the concept. If present, it shall
				have the content "Principles", and may have any children.
				
				The final child of the element shall only be present is the document is intended to
				double as an executable program. If present, it shall have the content "Program",
				and may have any children, which shall function as executable code.
			-
		-
			Poly Kaeon Documents
		-
			-
				A poly Kaeon document refers to a ONE document that consists of a root element with
				no content and an indefinite number of Kaeon documents as its children.
			-
		-
			Informal Kaeon Documents
		-
			-
				An informal Kaeon document refers to any document that follows an inexact version
				of the Kaeon document format.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents: 1 - Amenable Kaeon Document ]#

-
	Amenable Kaeon Document
-
	-
		Philosophy
	-
		-
			Over time, elements may be added to the principles section of this Kaeon Document. Each
			such element shall contain content consisting of the word "Amendment", followed by the
			number specifying the order in which it was added, and their children shall expand the
			terms of this document, and may also replace the content of the first element of this
			document. If the terms between two or more amendments conflict, the terms of the most
			recently added amendments shall overrule the terms of the pre-existing amendments.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library ]#

-
	Kaeon Library
-
	-
		Philosophy
	-
		-
			A Kaeon library is a set of directories that contain organized files.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				All of the contents of a Kaeon library are contained within a directory called the
				master directory. The name of the master directory will be the name of the library.
				
				A library directory, which the master directory is one of, may contain multiple
				library directories within it, in which case it may also contain one Kaeon
				document, may contain only a single Kaeon document, or may contain multiple
				miscellaneous files and directories.
				
				The name of library directory other than the master directory must consist of a
				number signifying its intended index relative to the other library directories
				within its parent directory, followed by a space, followed by a dash, followed by
				another space, followed by a string signifying the nature of its contents.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library: 1 - Kaeon Library Atlas ]#

-
	Kaeon Library Atlas
-
	-
		Philosophy
	-
		-
			A Kaeon library atlas is a network consisting of references from one Kaeon library to
			another and references from a Kaeon library to another resource, which are encoded in
			Kaeon documents within the Kaeon libraries from which they originate. 
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents: 3 - Document Paths: 1 - ONE Paths ]#

-
	ONE Paths
-
	-
		Philosophy
	-
		-
			A ONE path is a series of numbers used to identify a specific element within the scope
			a given element, where the first number in said sequence, zero, corresponds to said
			given element, and each subsequent number represents a child of the element represented
			by the number it follows, with said number specifying the index of the element it
			represents relative to its siblings, where indices start at one.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 3 - Kaeon Documents: 3 - Document Paths: 2 - Kaeon Library Paths ]#

-
	Kaeon Library Paths
-
	-
		Philosophy
	-
		-
			A Kaeon library path is a sequence of numbers used to specify a given document or
			directory within a Kaeon library, where the beginning of the sequence marks the root of
			the directory, a number above zero represents the number of the sub directory of the
			previous directory in the sequence that said number corresponds to, and zero, which
			always ends the sequence, corresponds to the sole document within the previous
			directory in the sequence.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 4 - FUSION ]#

-
	FUSION
-
	-
		Philosophy
	-	
		-
			FUSION is a system that allows any ONE element to serve as code.
		-
	-
		Principles
	-
		-
			Order of Operations
		-
			-
				Step One
			-
				-
					FUSION will be given a ONE element to start at.
				-
			-
				Step Two
			-
				-
					Based on the current element, FUSION will perform an operation.
					
					If the current element has no children, FUSION will proceed to step three.
					
					If the current element does have children, then based on the current element,
					FUSION will decide whether or not to trickle down to the current element's
					children.
					
					If it decides to do so, FUSION will shift focus the the current element's first
					child, and repeat step two. Otherwise, FUSION will proceed to step three.
				-
			-
				Step Three
			-
				-
					Based on current element, FUSION will perform an operation and generate a
					value.
					
					Any values previously generated by performing step three on the current
					element's children and stored by FUSION will then be deleted.
					
					FUSION will then decide based on the current element whether the generated
					value will be used as an argument when performing operations on the current
					element's parent.
					
					If it decides to use the value as an argument, the order in which it was
					generated relative to any such values generated by the siblings of the current
					element will be held relevant.
				-
			-
				Step Four
			-
				-
					Based on the current element, FUSION will decide whether or not to terminate.
					
					If FUSION decides not to terminate, it will decide based on the current element
					whether or not to jump to another element.
					
					If it chooses to jump to another element, any values that were generated during
					step three and stored by FUSION that were to be used as arguments when
					performing operations on another element will be deleted, and FUSION will loop
					back to step two.
					
					If it chooses not to jump to another element and the current element is
					followed by a sibling element, FUSION will shift focus to the next sibling and
					loop back to step two.
					
					If it chooses not to jump to another element and the current element is not
					followed by a sibling element but does have a parent, FUSION will shift focus
					to the current element's parent, and loop back to step three.
					
					If none of the aforementioned conditions are met, FUSION will terminate.
				-
		-
			Commands
		-
			-
				An element being operated on by FUSION is referred to as a command.
				
				By default, commands will do the following unless otherwise specified:
				
				At step two, they will perform no operation and will trickle down.
				
				At step three, they will perform no operation, generate a null value, and allow the
				generated value to be used as an argument for its parent.
				
				At step four, they will not terminate and will not jump to another element.
			-
		-
			Error Handling
		-
			-
				If an error occurs during at any step, FUSION will skip over the step and proceed
				as if nothing happened.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 4 - FUSION: 1 - Kaeon FUSION ]#

-
	Kaeon FUSION
-
	-
		Philosophy
	-
		-
			Kaeon FUSION is a dialect of FUSION.
			
			It starts only with the functionality necessary to expand its functionality at runtime.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 4 - FUSION: 1 - Kaeon FUSION: 1 - Conventions ]#

-
	Kaeon FUSION Conventions
-
	-
		Philosophy
	-
		-
			Kaeon FUSION establishes certain conventions in addition to those established by
			FUSION.
		-
	-
		Principles
	-
		-
			Host Environment
		-
			-
				The host environment may read from and alter the state of Kaeon FUSION as Kaeon
				FUSION runs.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 4 - FUSION: 1 - Kaeon FUSION: 2 - Interfaces ]#

-
	Interfaces
-
	-
		Philosophy
	-
		-
			Interfaces are modules that can alter the Kaeon FUSION interpreter at runtime.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 4 - FUSION: 1 - Kaeon FUSION: 3 - Use ]#

-
	Use
-
	-
		Philosophy
	-
		-
			The use command contains the content "Use". The letter case of the content is
			irrelevant. It may have an indefinite number of children.
			
			For each of its children, the use command will integrate the interface located at the
			path specified by the content of said child if said interface exists.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 5 - ACE ]#

-
	ACE
-
	-
		Philosophy
	-
		-
			ACE is a system that allows ONE elements to be interpreted as object nodes within an
			object model, structured according to their placement relative to each other.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 5 - ACE: 1 - ACE Reference ]#

-
	ACE Reference
-
	-
		Philosophy
	-
		-
			Certain elements within an ACE document may serve as references to objects defined
			elsewhere rather than as objects themselves.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 5 - ACE: 1 - ACE Reference: 1 - Standard ACE ]#

-
	Standard ACE
-
	-
		Philosophy
	-
		-
			Standard ACE is a standard for ACE elements that dictates that elements that serve as
			references should have the content "Reference", where letter case is irrelevant.
		-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 5 - ACE: 1 - ACE Reference: 2 - ACE Query ]#

-
    ACE Query
-
	-
		Philosophy
	-
		-
			The ACE query is the standard method for referencing an element within a ONE document
			using a ACE reference element.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				An ACE query is encoded into an element called the ACE query element which shall
				have the content "ACE", and shall be the sole child of the reference element.

				The ACE query element must either have a child with the content "Query" or the
				content "Index", and may also have a child with the content "Path", which if
				present shall have a child with content specifying the path of the ONE document to
				search for the referenced object in. If the "Path" element is not present, the
				element will be referenced from the current document.
				
				If the "Query" element is present, it shall have an object element as a child,
				indicating that the referenced object should be queried from the specified document
				to locate the object that most closely matches the child of said "Query" element,
				with objects closer to the referencing object taking priority, and with objects
				preceding the referencing object taking priority over those that follow it.

				If the "Index" element is present, it will have at least one but up to an
				indefinite number of children each with an integer number as their content,
				collectively specifying, in order, the index path from the root of the specified
				document to the referenced element.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 1 - ONE: 5 - ACE: 2 - Kaeon ACE ]#

-
	Kaeon ACE
-
	-
		Philosophy
	-
		-
			Kaeon ACE is a standard for using ACE elements to define a component-entity tree.
		-
	-
		Principles
	-
		-
			Components
		-
			-
				ACE elements that represent components shall have the content "Component", and may
				have any children.
			-
		-
			Entities
		-
			-
				ACE elements that represent entities shall have the content "Entity", and may have
				either component elements or entity elements as children.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 2 - Universal Preprocessor ]#

-
	Universal Preprocessor
-
	-
		Philosophy
	-
		-
			The Universal Preprocessor is a preprocessor that allows code from any programming
			language to be embedded as a preprocessor into any text file.
		-
	-
		Principles
	-
		-
			Token Sequences
		-
			-
				The Universal Preprocessor requires seven unique sequences of characters to be
				defined: the open sequence, the open directive sequence, the close protocol
				sequence, the open content sequence, the close directive sequence, the null
				sequence, and the wildcard sequence.
				
				It is not permitted for the sequences to be defined such that there may be any
				instances where two or more sequences conflict at a given location.
			-
		-
			Directives
		-
			-
				Preprocessor directives in the Universal Preprocessor shall be encoded in
				directives.
				
				Directives typically begin with an open sequence, which is followed by the name of
				the language the directive is written in, referred to as the directive language,
				which is followed by an open content sequence, which is followed by any valid code
				written in the directive language, referred to as the directive content, and end
				with a close directive sequence. A directive following this format is called an
				explicit directive.

				Alternatively, a directive may begin with an open directive sequence, which is
				followed by any valid code written in any language, referred to as the directive
				content, and end with a close directive sequence. A directive following this format
				is called an implicit directive.

				Token sequences used for Universal Preprocessor directives can be nullified in any
				manner otherwise used to nullify or escape characters by the host language if
				outside a directive, or by the directive language if inside a directive.

				If said token sequences are not escaped within another directive, then a nested
				directive shall operate on the directive content.
			-
		-
			Host Language
		-
			-
				The host language determines how the tokens used by the Universal Preprocessor are
				escaped when located outside other directives.

				The host language may be explicitly set using a host protocol, which sets the host
				language for all Universal Preprocessor tokens that follow it.
				
				Host protocols begin with an open sequence, which is followed by the name of the
				language to set as the host language, which is followed by a close protocol
				sequence.

				If the host language is not declared, or is declared as using a null sequence, then
				the host language shall be plain text, and there shall be no protocol for escaping
				tokens.
			-
		-
			Execution
		-
			-
				Each directive shall execute as code in the language of its directive content in
				order of its placement.

				The state of the preprocessor shall carry over from directive to directive to
				whatever extent possible.

				Each directive shall take three arguments, the first being the source code without
				the unescaped directives as a string, the second being the index of its respective
				starting open paren as an integer number, and the third being a list of
				miscellaneous values passed to the Universal Preprocessor as arguments.

				Any text logged to standard out by the code will be injected into the source text
				at the index of the starting tag, but if the code returns a non-null value, the
				string form of said value shall replace the source text altogether.
			-
		-
			Auto Detection
		-
			-
				For an implicit directive, or for an explicit directive where the directive
				language is specified using a wildcard sequence, the language of the directive
				content shall be detected automatically.
			-
		-
			Commenting
		-
			-
				If the directive language for a given directive is declared using a null sequence,
				or as any string not recognized as a language alias, then the contents of the
				directive shall not execute, thus making the directive function as a comment.
			-

#[ Kaeon United Specification: 1 - Core: 1 - Code: 2 - Universal Preprocessor: 1 - Standard Universal Preprocessor ]#

-
	Standard Universal Preprocessor
-
	-
		Philosophy
	-
		-
			The standard Universal Preprocessor is a specification for the standard token sequences
			used by the Universal Preprocessor.
		-
	-
		Principles
	-
		-
			Open Sequence
		-
			-
				The open sequence in the standard Universal Preprocessor consists of an open paren
				followed by a closed square bracket.
			-
		-
			Open Directive Sequence
		-
			-
				The open directive sequence in the standard Universal Preprocessor consists of an
				open paren followed by a closed angle bracket.
			-
		-
			Close Protocol Sequence
		-
			-
				The close protocol sequence in the standard Universal Preprocessor consists of an
				open square bracket followed by a closed paren.
			-
		-
			Open Content Sequence
		-
			-
				The open content sequence in the standard Universal Preprocessor consists of an
				open square bracket followed by a closed angle bracket.
			-
		-
			Close Directive Sequence
		-
			-
				The close directive sequence in the standard Universal Preprocessor consists of an
				open angle bracket followed by a closed paren.
			-
		-
			Null Sequence
		-
			-
				The null sequence in the standard Universal Preprocessor consists of a tilde.
			-
		-
			Wildcard Sequence
		-
			-
				The wildcard sequence in the standard Universal Preprocessor consists of an
				asterisk.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone ]#

-
	Philosopher's Stone of Computation
-
	-
		Philosophy
	-
		-
			The Philosopher's Stone of Computation is an interface for dynamically invoking any
			operation such that if said operation causes an error then said operation shall
			terminate, said error shall be caught, and a null value shall be returned, and if said
			operation finishes successfully, then if said operation returns a value, said value
			shall be returned, and if said operation returns no value, a null value shall be
			returned.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Atlas ]#

-
	Philosopher's Atlas
-
	-
		Philosophy
	-
		-
			A directed graph of modules where said modules may be of any type is referred to as a
			Philosopher's Atlas.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Atlas: 1 - Atlas Policy ]#

-
	Atlas Policy
-
	-
		Philosophy
	-
		-
			An atlas policy is an attribute assigned to a connection in a Philosopher's Atlas.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Atlas: 2 - Philosopher's Cross ]#

-
	Philosopher's Cross
-
	-
		Philosophy
	-
		-
			A Philosopher's Cross is a database that may act as a node on a Philosopher's Atlas.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 2 - Philosopher's Retrieval ]#

-
	Philosopher's Retrieval
-
	-
		Philosophy
	-
		-
			Philosopher's Retrieval is when a collection of modules that match specified criteria
			is retrieved from a set.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium ]#

-
	Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A Philosopher's Medium is a standard for a set of functionality which a module that
			abides by it shall have.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 1 - Standard Philosopher's Medium ]#

-
	Standard Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the standard Philosopher's Medium shall have a function known
			as the standard function.
		-
	-
		Principles
	-
		-
			Standard Function
		-
			-
				The standard function may take any parameters.

				The operations it performs and the value it returns may be redefined for every
				module that abides by the standard Philosopher's Stone Medium. There are no limits
				on what said operations and value may be.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 1 - Standard Philosopher's Medium: 1 - Standard Function Conventions ]#

-
	Standard Function Conventions
-
	-
		Philosophy
	-
		-
			The standard function conventions define the default properties for the standard
			function within a module that abides by the standard Philosopher's Medium.

			The conventions also assert that any module that abides by the standard Philosopher's
			Medium shall be known as a standard Philosopher's Stone Module.
		-
	-
		Principles
	-
		-
			Standard Function Defaults
		-
			-
				By default, the standard function shall perform no operations and shall return a
				null value.
			-
		-
			Standard Function Default Alias
		-
			-
				The standard function default alias for the standard function within a standard
				Philosopher's Stone module.

				The standard function default alias is "On Call".
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 2 - Regulated Philosopher's Medium ]#

-
	Regulated Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the regulated Philosopher's Medium shall have the on incoming 
			function and the on outgoing function, and shall be known as a regulated Philosopher's
			Stone module.

			The aforementioned functions are used to restrict access to certain regions of a given
			regulated during a traversal of a Philosopher's Atlas.
		-
	-
		Principles
	-
		-
			Functions
		-
			-
				On Incoming
			-
				-
					The on incoming function takes a list of modules representing a traversal path,
					as well as a value specifying any additional information as arguments.
					
					It returns true if the module it was called from should be considered part of a
					given traversal, and returns false otherwise.
					
					It may be redefined for each regulated Philosopher's Stone module, and may
					perform any operations before returning.

					It returns true by default.
				-
			-
				On Outgoing
			-
				-
					The on outgoing function takes a list of module representing a traversal path
					as well as a value specifying any additional information as arguments. The list
					must contain at least two module, with the second to last module in the list
					being the one the function was called from, and the last module in the list
					being the next one in the projected traversal.
					
					It returns true if a given traversal should continue from the module it was
					called from to the last stone in the passed in list, and returns false
					otherwise.
					
					It may be redefined for each regulated Philosopher's Stone module, and may
					perform any operations before returning.
					
					It returns true by default.
				-
		-
			Traversals
		-
			-
				When a traversal of a Philosopher's Atlas travels through a regulated Philosopher's
				Stone module, the on incoming function of the regulated Philosopher's stone module
				in question shall be called using a list containing every previously traversed
				module, as well as a value specifying any additional information. If the on
				incoming function returns true, the traversal shall progress to the module in
				question.
				
				If a traversal has progressed past the on incoming function of a given regulated
				Philosopher's Stone module, the on outgoing function of said regulated
				Philosopher's Stone module must be called for every module that the regulated
				Philosopher's Stone module in question is connected to that itself has not yet been
				traversed. A list containing every previously traversed module, the regulated
				Philosopher's Stone module in question, and the next module in the projected
				traversal shall be passed to the on outgoing function, along with a value
				specifying any additional information. The traversal will proceed to each
				connection that the on outgoing function returns true for.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 3 - Modifiable Philosopher's Medium ]#

-
	Modifiable Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the modifiable Philosopher's Medium shall have the modify
			function, which shall either one or two values, with the first value representing
			either data or functionality and the second value, if present, representing the desired
			address for the specified data or functionality within the module. The first value
			shall be inserted where possible within the module, and if the second value is present,
			the first value shall be inserted such that it may be addressed according the second
			value. Any existing values within the module that conflict with the new value shall be
			deleted.
			
			A module that abides by the modifiable Philosopher's Medium shall be known as a
			modifiable Philosopher's Stone module.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 4 - Serializable Philosopher's Medium ]#

-
	Serializable Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the serializable Philosopher's Medium shall have the serialize
			function, which serializes the module and returns it as a string, and the deserialize
			function, which takes a serialized module in the form of a string and converts the
			state of the module it was called from to the state of the serialized module that was
			passed to it.
			
			A module that abides by the serializable Philosopher's Medium shall be known as a
			serializable Philosopher's Stone module.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 5 - Generator Philosopher's Medium ]#

-
	Generator Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the generator Philosopher's Medium serves as a module that can
			spawn other modules, and can also take correlation into account.
		-
	-
		Principles
	-
		-
			Functionality
		-
			-
				A module that abides by the generator Philosopher's Medium has three functions.
				
				The first function is the generate function. This function takes one value and a
				number between zero and one, and returns an value that correlates to the passed in
				value as well as specified by the passed in number.
				
				The second function is the degenerate function. This function takes one value and a
				number between zero and one. The value is the output of the generate function for
				an unknown input, and the number represents how well the unknown input and the
				given output match up. Based on this correlation, the function returns a value that
				is as close as possible to a value that would cause the given output to be returned
				if passed to the generate function with the given correlation number.
				
				The third function is the correlate function. This function takes two values, and
				returns a number between zero and one based on how well the second value correlates
				to the first value assuming that the second value is output and the first value is
				the input paired with an unknown correlation value for the generate function.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 6 - SOUL Philosopher's Medium ]#

-
	SOUL Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the SOUL Philosopher's Medium serves as a universal black box
			for machine learning models.

			A module that abide by the SOUL Philosopher's Medium shall be known as a SOUL, and must
			also abide by the generator Philosopher's Medium.
		-
	-
		Principles
	-
		-
			Functionality
		-
			-
				A module that abides by the SOUL Philosopher's Medium contains a corpus of
				correlations between input and output values.
				
				In addition to the functions specified by the generator Philosopher's Medium, a
				SOUL also has the train function. This function takes two values and a number
				between zero and one. The first value is the input, the second value is the output,
				and the number represents how well the input and the output match up. Based on this
				correlation, the function updates the corpus.

				The functions of a SOUL specified by the generator Philosopher's Medium must take
				said SOUL's corpus into account.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 6 - SOUL Philosopher's Medium: 1 - SOUL Core ]#

-
	SOUL Core
-
	-
		Philosophy
	-
		-
			A SOUL core is a standard Philosopher's Stone module containing SOULs for processing
			any data that passes through it via a Philosopher's Atlas.
		-
	-
		Principles
	-
		-	
			Functionality
		-
			-
				For every other module that a SOUL core is connected to via a Philosopher's Atlas,
				it must contain two SOULs, the gateway SOUL and the transformation SOUL
				respectively.
				
				Every time a SOUL core receives a value through the standard function, it must run
				the value through each gateway SOUL's generate function to produce a value
				representing either a positive or a negative result. If the result is positive, the
				generate function of the transformation SOUL that corresponds the gateway SOUL in
				question shall be called using a correlation argument of one, and then the gateway
				SOUL's respective connected module's standard function will be called using the
				aforementioned transformation SOUL's generate function's output.
				
				Additionally, a SOUL core shall have an operation function, which shall take a
				single value and may be overridden to perform any operation based on said value.
				The operation function shall be called using every value passed to its respective
				SOUL core's standard function.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 3 - Philosopher's Medium: 6 - SOUL Philosopher's Medium: 2 - SOUL Entity ]#

-
	SOUL Entity
-
	-
		Philosophy
	-
		-
			A SOUL entity is a module with input channels that can receive strings from other
			modules, output channels that can export strings to other modules, and input channels
			that can receive feedback from other modules in the form of numbers from zero to one,
			with higher numbers indicating positive feedback, and lower numbers indicating negative
			feedback.

			A SOUL entity ought to behave such that it attempts to maximize the positive feedback
			received through its numerical input channels by adjusting what it exports through its
			string output channels according to what it receives through its string input channels.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 4 - Philosopher's Conventions: 1 - Philosopher's Script ]#

-
	Philosopher's Script
-
	-
		Philosophy
	-
		-
			A Philosopher's Script is a single set of data that may be interpreted differently by
			different processes.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 4 - Philosopher's Conventions: 2 - Philosopher's Evolution ]#

-
	Philosopher's Evolution
-
	-
		Philosophy
	-
		-
			Philosopher's evolution is a general purpose formula for executing a genetic algorithm.
		-
	-
		Principles
	-
		-
			Functionality
		-
			-
				Philosopher's evolution is implemented in a function called the evolve function,
				which takes five arguments.
				
				The first argument is the process function, which takes a single value as an
				argument and may return any value.

				The second argument is the judge function, which takes a single value as an
				argument and shall return a number between zero and one, inclusive.

				The third argument is the threshold value, which shall be a number between zero and
				one, inclusive.

				The fourth argument is the mutate function, which takes a single value as an
				argument and may return any value. If the mutation function passed in is null, a
				default mutation function shall be used it its place.

				The fifth argument is the initial genetic value, and may be of any type.

				The evolve function shall run the process function with the current genetic value,
				which at first shall be the initial genetic value. It shall then take the output of
				the process function and run the judge function with it. If the judge function
				returns a value greater than or equal to the threshold value, the evolve function
				shall return the current genetic value. Otherwise, the evolve function shall run
				the mutate function with the genetic value that resulted in the highest output thus
				far from the judge function, and the output from the mutate function shall then
				replace the current genetic value, and the evolve function shall loop back to the
				beginning.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 5 - Philosopher's Series: 1 - Dot Net ]#

-
	Dot Net
-
	-
		Philosophy
	-
		-
			The Dot Net is a network of machines called Dots that allow digital machines to store
			and transfer data.
		-
	-
		Principles
	-
		-
			Dots
		-
			-
				A Dot is a machine that has the ability to store and transfer data.
				
				A machine may encode data in Dots by broadcasting it to all available Dots. The
				Dots that receive the data will communicate amongst themselves to determine where
				the data should be encoded. Once the data has been stored, the machine that sent
				the data will then receive an alias for the encoded data, which will allow any
				machine to access said data by said alias, along with the credentials necessary to
				modify or delete said data. If no Dots with sufficient memory are available to
				encode a given unit of data, an error message will be returned to the machine that
				sent said data.
				
				Machines may also use Dots as a means of transferring data between machines. When
				being used in this manner, Dots will relay the data between each other but will not
				store it.
			-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 5 - Philosopher's Series: 1 - Dot Net: 1 - Standard Dot ]#

-
	Standard Dot
-
	-
		Philosophy
	-
		-
			A Standard Dot is a Dot with wireless communication functionality, that generates its
			own power in a renewable manner, that automatically backs up data from other Dots, and
			that is free and open for anonymous use.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 5 - Philosopher's Series: 2 - Cross Reality Computer ]#

-
	Cross Reality Computer
-
	-
		Philosophy
	-
		-
			A cross reality computer is a personal computer embedded into a standalone portable
			device that supports both augmented reality and virtual reality.
		-

#[ Kaeon United Specification: 1 - Core: 2 - Philosopher's Stone: 5 - Philosopher's Series: 2 - Cross Reality Computer: 1 - Standard Cross Reality Computer ]#

-
	Standard Cross Reality Computer
-
	-
		Philosophy
	-
		-
			A standard cross reality computer is a cross reality computer that is capable of
			connecting to a cellular network.
		-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 1 - ONE+ ]#

ONE+
	
	Philosophy
		
		-
			ONE+ is a syntactic superset of ONE.
		-
	
	Principles
		
		Character Sequences
			
			-
				In addition to the three character sequences required by ONE, ONE+ requires the
				following unique character sequences: The segregating sequence, the nested
				sequence, the denested sequence, the open scope sequence, the close scope sequence,
				the open domain sequence, the close domain sequence, the escape sequence, the
				escape scope sequence, the encoded escape scope sequence, the alternate breaking
				sequence, the alternate nesting sequence, the comment sequence, the open comment
				sequence, the close comment sequence, and the blank sequence. It is not permitted
				for the sequences to be defined such that there may be any instances where two or
				more sequences conflict at a given location.
				
				In ONE+, it is possible to have more than one character sequence for each defined
				sequence.
			-
		
		Syntax
			
			-
				ONE+ permits sequences of characters to exist in between ONE elements. Such
				sequences are referred to as plus sequences.
				
				Plus sequences of characters that exist between the beginning of the file, a
				nesting sequence, or a breaking sequence, and a breaking sequence are referred to
				as definitions. Definitions can be nested just like elements depending on how many
				nesting sequences immediately precede them.
			-

		Plus Sequences
			
			Blank Plus Sequences
				
				-
					A blank plus sequence is an plus sequence made up entirely of blank sequences.
					They have no effect on the encoded elements.
				-
				
			Escape Plus Sequences
				
				-
					An escape plus sequence is an plus sequence that consists of an escape sequence
					followed by another sequence of characters. If the sequence of characters
					immediately following the escape sequence would normally have an effect on the
					document, the effect will be nullified. The escape sequence itself will not be
					encoded into any elements.
				-
			
			Escape Scope Plus Sequences
				
				-
					An escape scope plus sequence is an plus sequence that begins with an escape
					scope sequence and ends with another escape scope sequence. If any characters
					located between the two escape scope sequences would normally have an effect on
					the document, the effect will be nullified. The escape scope sequences
					themselves will not be encoded into any elements.
				-
				
			Encoded Escape Scope Plus Sequences
				
				-
					An encoded escape scope plus sequence is an plus sequence that begins with an
					encoded escape scope sequence and ends with another encoded escape scope
					sequence. If any characters located between the two encoded escape scope
					sequences would normally have an effect on the document, the effect will be
					nullified. The encoded escape scope sequences themselves will be encoded into
					the elements.
				-
			
			Extended Escape Scope Plus Sequences
			
				-
					If an escape scope plus sequence or encoded escape scope plus sequence does not
					properly close within the definition it occurs within, and said definition is
					followed by another definition, the sequence will continue through to the next
					definition.
				-
			
			Escape Character Plus Sequences
				
				-
					An escape character plus sequence is an plus sequence that consists of an
					escape sequence followed by either an alternate breaking sequence or an
					alternate nesting sequence. It will not be encoded into the document.
					
					If the escape character plus sequence contains an alternate breaking sequence,
					a breaking sequence will be encoded into the document in place of the escape
					character plus sequence.
					
					If the escape character plus sequence contains an alternate nesting sequence, a
					nesting sequence will be encoded into the document in place of the escape
					character plus sequence.
				-
			
			Comment Plus Sequences
				
				-
					A comment plus sequence is an plus sequence that starts with a comment sequence
					and ends with a breaking sequence. All characters in the plus sequence will
					have no effect on the document.
				-
				
			Comment Block Plus Sequences
				
				-
					A comment plus sequence is an plus sequence that starts with an open comment
					sequence and ends with a close comment sequence. All characters in the plus
					sequence will have no effect on the document.
				-
			
			Plus Element Definitions
				
				-
					A plus element definition is a definition that does not consist entirely of
					blank sequences. All characters except those nullified by comments or escape
					sequences or are blank sequences leading or trailing the definition or comments
					within the definition will be encoded into an element.
				-
			
			Multiple Plus Element Definitions
				
				-
					It is possible to separate the content encoded through a plus element
					definition across multiple elements.
					
					The content can be separated with the following character sequences: the
					segregating sequence, the nested sequence, the denested sequence, the open
					scope sequence, the close scope sequence, the open domain sequence, and the
					close domain sequence. Any blank sequences preceding or following the
					separating sequence will not be encoded into the elements, nor will the
					separating sequence itself.
					
					If a segregating sequence or open scope sequence is used as the separating
					sequence, the element following it will be a sibling of the element preceding
					it.
					
					If a close scope sequence is used as the separating sequence, the element
					following it will be a sibling of the element preceding the corresponding
					open scope sequence.
					
					If a nested sequence or open domain sequence is used as the separating
					sequence, the element following it will be a child of the element preceding it.
					
					If a closed domain sequence is used as the separating sequence, the element
					following it will be a sibling of the element preceding the corresponding open
					domain sequence.
					
					If a denested sequence is used as the separating sequence, the element
					following it will be a sibling of the parent of the preceding element.
				-
			
			Nesting
			
				-
					An element defined in a ONE element definition or the first element defined in
					a plus element definition nested beneath a plus element definition will be a
					child of the last element defined by the parent plus element definition that is
					not followed by a closed domain sequence or denested sequence.
					
					If a multiple plus element definition is ended with a nested sequence or an
					open domain sequence, elements defined following said plus sequence will define
					children of the last element defined by said plus sequence regardless of the
					nest level of said elements, until an excess denested sequence or close domain
					sequence is used respectively.
				-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 1 - ONE+: 1 - Standard ONE+ Language ]#

Standard ONE+ Language

	Philosophy
	
		-
			The standard variant of the ONE+ Language defines specific sequences of characters as
			the required sequences of the ONE+ language.
			
			The standard variant of the ONE+ language also uses the same sequences of characters as
			the standard variant of the ONE language for the terminating and breaking sequences.
		-
	
	Principles
		
		Standard Sequences
			
			Nesting Sequence
				
				-
					The nesting sequence will be defined by the nest definition line. The nest
					definition line is the first line in the document to have a length greater than
					zero and to begin with either a tab or a space but not to consist solely of
					tabs and spaces.
					
					If no line in the document satisfies the requirements of the nest definition
					line, the nesting sequence will be a tab.
					
					If the nest definition line exists, the nesting sequence will be defined as a
					string containing the first character in the nest definition line. For every
					character nest definition line from the second character, inclusive, to the
					first character that does not match the first character in the nest definition
					line, exclusive, said character will be appended to the nesting sequence.
				-
		
			Segregating Sequence
			
				-
					In the standard variant of the ONE+ Language, the segregating sequence is a
					comma.
				-
				
			Nested Sequence
				
				-
					In the standard variant of the ONE+ Language, the nested sequence is a colon.
				-
				
			Denested Sequence
				
				-
					In the standard variant of the ONE+ Language, the denested sequence is a
					semicolon.
				-
			
			Open Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the open scope sequence is an
					open parenthesis.
				-
			
			Close Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the close scope sequence is a
					closed parenthesis.
				-
			
			Open Domain Sequence
				
				-
					In the standard variant of the ONE+ Language, the open domain sequence is an
					open curly bracket.
				-
			
			Close Domain Sequence
				
				-
					In the standard variant of the ONE+ Language, the close domain sequence is a
					closed curly bracket.
				-
			
			Escape Sequence
				
				-
					In the standard variant of the ONE+ Language, the escape sequence is a tilde.
				-
			
			Escape Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the escape scope sequence is a
					single quote.
				-
			
			Encoded Escape Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the encoded escape scope sequence
					is a double quote.
				-
			
			Alternate Breaking Sequence
				
				-
					In the standard variant of the ONE+ Language, the alternate breaking sequence
					is an 'n'.
				-
			
			Alternate Nesting Sequence
				
				-
					In the standard variant of the ONE+ Language, the alternate nesting sequence is
					a 't'.
				-
			
			Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the comment sequence is a pound
					sign.
				-
			
			Open Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the open comment sequence is a
					pound sign followed by an open square bracket.
				-
			
			Close Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the close comment sequence is a
					closed square bracket followed by a pound sign.
				-
			
			Zero Sequence
				
				-
					In the standard variant of the ONE+ Language, the zero sequence is an open
					square bracket, followed by a zero, followed by a closed square bracket.
				-
			
			Blank Sequence
				
				-
					In the standard variant of the ONE+ Language, the blank sequence is either a
					space or a tab.
				-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 2 - ONE Files: 1 - ONE List Form ]#

ONE List Form

	Philosophy
	
		-
			ONE list form is an alternative way of representing ONE elements as lists rather than
			trees.
		-
	
	Principles
		
		Structure
			
			-
				Any list of objects may be used to represent a ONE element in ONE list form.
				
				The string form of the first object in the list will be said element's content, and
				every object following the first object will represent one of said element's
				children.
				
				If an empty list is interpreted as an element in ONE list form, said element will
				have an empty string as its content.
				
				When interpreting an object within a list as an element's child, the string form of
				the object will be said child's content if the object is not a list, and if the
				object is a list, said child will be said list interpreted as an element in ONE
				list form.
			-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 2 - ONE Files: 1 - ONE List Form: 1 - Extended ONE List Form ]#

Extended ONE List Form

	Philosophy
	
		-
			A ONE element nested within another element may be represented as a list using extended
			ONE list form. 
		-
	
	Principles
	
		List Structure
		
			-
				A list representing an element in extended ONE list form contains two lists, the
				first of which represents an element that has no parent in ONE list form, and the
				second of which containing integer numbers greater than or equal to one specifying,
				in order, the indexes leading to the desired nested element.
			-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 2 - ONE Files: 2 - ONE File Extensions ]#

ONE File Extensions

	Philosophy
	
		-
			A file containing a ONE document written in only the standard ONE language should have
			the extension ".one".
			
			A file containing a ONE document written in the standard ONE+ language should have the
			extension ".op".
		-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 2 - ONE Files: 3 - ONE Abstract Syntax Tree ]#

ONE Abstract Syntax Tree

	Philosophy
	
		-
			A ONE abstract syntax tree is a ONE element analogous to the abstract syntax tree of a
			given document in a language that can be represented as an abstract syntax tree.
		-
	
	Principles
	
		Structure
		
			-
				A ONE abstract syntax tree contains as its content the name of the language the
				abstract syntax tree represents and every child of it is a node on the tree. Each
				node element has as its content the content of the node it represents and has other
				node elements corresponding to the children of the node it represents. Node
				elements must be arranged in the same order as the nodes they represent.
			-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 1 - ONE Processing: 2 - ONE Files: 4 - ONE File Document ]#

ONE File Document

	Philosophy

		-
			A ONE file document is a ONE document generated from a file or folder and its contents.
		-

	Principles

		Generation

			-
				A folder shall correspond to a ONE element where the name of the folder is its
				content and where each file or folder within said folder corresponds to a child of
				said element, ordered according to their order relative to each other.

				A file shall correspond to a ONE element where the name of said file is its content
				and where, if said file is not a ONE document, said element has one child where the
				content of said child is the content of said file, and if said file is a ONE
				document, said element has the childen of the root element of said ONE document as
				its children.
			-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 2 - ONE Rendering ]#

ONE Rendering

	Philosophy

		-
			ONE rendering is the process of taking a document that was originally composed in a
			format other than ONE and converting its content into a ONE document, the end result
			being a ONE rendered document.
		-

	Principles

		ONE Derendering

			-
				ONE derendering is the process of taking a document that was originally composed in
				ONE and converting its content into a document in another format, the end result
				being a ONE derendered document.
			-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 1 - ONE Conventions: 3 - Kaeon Metadata Document ]#

Kaeon Metadata Document

	Philosophy
	
		-
			A Kaeon metadata document is a ONE document that may accompany a Kaeon document or
			Kaeon library to provide information regarding the author or authors, time of writing,
			terms of use, reference information, and miscellaneous notes.
		-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 2 - Universal Preprocessor: 1 - Langauge Aliases ]#

Universal Preprocessor Language Aliases

	Philosophy

		-
			This document specifies the aliases that different languages may use when being
			declared as the host language or as a directive language.

			All aliases declared in this document are case insensitive.
		-

	Principles

		Languages

			Kaeon FUSION

				-
					Kaeon FUSION may use the aliases "Kaeon FUSION" and "KF".
				-

			JavaScript

				-
					JavaScript may use the aliases "JavaScript" and "JS".
				-

#[ Kaeon United Specification: 2 - Suite: 1 - Code: 2 - Universal Preprocessor: 2 - Assembler ]#

Universal Preprocessor Assembler

	Philosophy

		-
			The universal preprocessor may be used to produce binary data by running it such that a
			directive, if it does not return a value of null, may return either a string or a byte
			array.

			In the latter case, the universal preprocessor shall stop and the output of the process
			shall be said byte array.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 1 - Kaeon FUSION Conventions ]#

Kaeon FUSION Standard Conventions

	Philosophy
	
		-
			The Kaeon FUSION Standard Conventions establish standards that Kaeon FUSION
			implementations are expected to support.
		-
	
	Principles
		
		String Forms

			-
				All values returned by Kaeon FUSION commands must be convertible to strings.
				
				When a value is converted to a string, said string is referred to as the value's
				string form.
			-

		Command Priority
			
			-
				Certain Kaeon FUSION commands may hold priority over others, meaning that commands
				every time Kaeon FUSION trickles down at a command, the command's children will be
				rearranged first based on their priority and then based on their current order.
			-
	
		Module Aiases
		
			-
				Kaeon FUSION interfaces may be referenced through aliases as opposed to their file
				paths. The letter case of said aliases is irrelevant.
			-
	
		Return Value
		
			-
				Whenever a Kaeon FUSION command returns a value, said value may be designated as
				the return value, which will be returned to Kaeon FUSION's host environment after
				it terminates.
				
				There may only be one return value at a time.
			-
		
		Workspace
		
			-
				The workspace refers to the directories that Kaeon FUSION will import resources
				from. The directories that compose the workspace must be arranged into a hierarchy.
				
				When attempting to locate a given resource, Kaeon FUSION will search each directory
				in the order of their priorities until either the resource is found or there are no
				more directories to search.
				
				By default, the workspace will consist of the local directory, the root directory,
				and the internet, but said directories may be added to or removed from the
				workspace.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 2 - ACE Conventions: 1 - Kaeon ACE: 1 - Kaeon ACE Directives ]#

Kaeon ACE Directives

	Philosophy
	
		-
			Kaeon ACE directives are ACE elements which may be used as the children of component
			objects in Kaeon ACE to specify directives to the host environment.
		-
	
	Principles
	
		Structure
		
			-
				A directive element's content will be "Directive", and it may have any children.
			-
		
		Use
		
			-
				A use directive is a type of directive that instructs the host environment to
				import additional modules. It shall have a child with the content "Use", where
				letter case is irrelevant, and the children of said child shall each have content
				specifying the paths or names of modules to import.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 2 - ACE Conventions: 1 - Kaeon ACE: 2 - Kaeon ACE Engine ]#

Kaeon ACE Engine
	
	Philosophy
		
		-
			The Kaeon ACE engine is the standard host environment for the content specified in a
			Kaeon ACE document.
		-
	
	Principles
		
		Structure
			
			-
				The Kaeon ACE engine is built on a Philosopher's Atlas.
				
				The core of the framework is a single Philosopher's Stone module, referred to as
				the Kaeon ACE Stone.
				
				The rest of the framework consists of and processes, which are implemented as
				Philosopher's Stone modules.
			-
			
			Kaeon ACE Stone
				
				-
					The Kaeon ACE Stone will contain a Kaeon ACE Document.
					
					The Kaeon ACE Stone is connected to all processes.
				-
			
			Processes
				
				-
					Processes perform operations for the framework using the entities as an
					interface to the developer.
					
					Each process is connected to the Kaeon ACE Stone.
					
					A process may be connected to more than one Kaeon ACE Stone.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 2 - ACE Conventions: 1 - Kaeon ACE: 2 - Kaeon ACE Engine: 1 - Standard Kaeon ACE Engine ]#

Standard Kaeon ACE Engine

	Philosophy
	
		-
			The standard Kaeon ACE Engine is a standard governing how connections must be handled
			in implementations of the Kaeon ACE Engine using standard Philosopher's Stones.
		-
	
	Principles
	
		Connections
		
			-
				Connections from the Kaeon ACE Stone to process stones must be public.
				
				Connections from process stones to the Kaeon ACE stone must be private.
				
				Any other connection from the Kaeon ACE Stone or a process stone to another
				Philosopher's stone must be private.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 2 - ACE Conventions: 2 - ACE Meta ]#

ACE Meta
	
	Philosophy
		
		-
			An ACE Meta is a type of ACE element that establishes a common interface between
			various unrelated environments.
		-
	
	Principles
		
		Structure
			
			-
				An ACE Meta element must the content "ACE Meta", and must have two children, the
				first of which must have the content "Source", and the second of which must have
				the content "Data".
				
				The source element must have a child with content that specifies a certain software
				environment.
				
				The data element must have content that contains saved data for the environment
				specified by the child of the source element.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 1 - ONE: 2 - ACE Conventions: 3 - Reduced ACE ]#

Reduced ACE

	Philosophy
	
		-
			Reduced ACE is a convention for ACE objects and documents. ACE objects and documents
			that adhere to the convention prohibit the use of ACE references.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Stone Conventions: 1 - Mediums: 1 - Taggable ]#

Taggable Philosopher's Medium
	
	Philosophy
	
		-
			A module that abides by the taggable Philosopher's Medium shall contain a list of
			strings which act as identification tags for the module.

			A module that abides by the taggable Philosopher's Medium shall be known as a tagged
			Philosopher's Stone module.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Stone Conventions: 2 - Philosopher's Crystal ]#

Philosopher's Crystal

	Philosophy
	
		-
			A philosopher's crystal is a single module is created to take the place of multiple
			modules within a Philosopher's Atlas. The process of converting multiple modules into a
			philosopher's crystal is referred to as crystallization.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Stone Conventions: 3 - Connections: 1 - Private Connection ]#

Private Connection

	Philosophy

		-
			A private connection is a type of connection in a Philosopher's Atlas.

			A private connection will not allow a traversal to pass through it unless said
			traversal began at the module that said connection goes out from.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Stone Conventions: 3 - Connections: 2 - Reduced Connection ]#

Reduced Connection

	Philosophy

		-
			A reduced connection is a type of connection in a Philosopher's Atlas.

			If a given module may only access another by traversing through a reduced connection,
			any argument passed from the former module to the latter module must be converted to a
			string before being passed to the latter module. Likewise, any value returned by the
			latter module must be converted into a string before being returned to the former
			module.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 1 - Philosopher's Stone Conventions: 4 - Standard Module ]#

Standard Module

	Philosophy

		-
			A standard module is a module that abides by the standard, regulated, modifiable,
			serializable, and taggable Philosopher's Mediums.
		-
	
	Principles

		Tags

			-
				For identification purposes, the tags specified by the taggable Philosopher's
				Medium shall ignore letter case and white space for standard modules.
			-
		
		Traversals

			-
				Traversals of Philosopher's Atlases initiated by or from standard modules should
				acknowledge private and reduced connections.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL ]#

Standard SOUL
	
	Philosophy
		
		-
			A standard SOUL is a SOUL implemented using a standard module, along with certain
			conventions to ensure cross compatibility.
		-
	
	Principles

		Input and Output

			Object Types

				-
					Objects passed to the train, generate, and correlate functions in a standard
					SOUL must be lists of numbers between zero and one, inclusive.
				-
			
			String Conversion

				-
					Strings may be converted to and from a list of numbers for use as inputs and
					outputs for standard SOULs where each character corresponds to its character
					code divided by the maximum character value if the character code is greater
					than zero, or to zero if the character code is zero.

					The default character encoding for use with a standard SOUL is UTF-32.
				-
		
		The Optimize Function

			-
				Standard SOULs shall have an optimize function which optimizes the SOUL's internal
				representation of its corpus.
			-
		
		SOUL Models
			
			-
				As there are various ways of implementing artificial intelligence, there are
				various ways of implementing a SOUL, some of which my be more suited to certain
				tasks.
				
				The various possible implementations of a standard SOUL are referred to as models.
				
				Each model must have a name with which it can be identified.
				
				Therefore, the standard SOUL must have a function for switching what model it is
				currently using, as well as a function for passing arguments to said model.
				
				A SOUL may only use one model at a time for processing, but it may train multiple
				models at once.

				Each model ought to have a custom file format storing its state.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map ]#

Data Map

	Philosophy

		-
			A data map is a set of input-output pairs where the input is a vector of indefinite
			length where each element is a number between zero and one, inclusive, and the output
			is a single number between zero and one, inclusive.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 1 - Cleansing ]#

Data Map Cleansing

	Philosophy

		-
			Data map cleansing is a process in which for a given data map, for all sets of points
			with matching input vectors, all are removed from the data map save for the most
			recently added point in each of said sets.

			A data map that has had data map cleansing applied to it is referred to as a cleansed
			data map.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 2 - Generation ]#

Data Map Generation

	Philosophy

		-
			Data map generation is any process in which a given data map and a vector of any length
			containing numbers between zero and one, inclusive, may be used to generate an output
			number between zero and one, inclusive, assuming said vector is a hypothetical input in
			a hypothetical input-output pair within said data map and said output number was the
			corresponding output in the input-output pair.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 2 - Generation: 1 - Data Map Curve ]#

Data Map Curve

	Philosophy

		-
			A data map curve is a multidimensional curve of best fit generated for a data map to be
			used in data map generation via curve regression.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 2 - Generation: 1 - Data Map Curve: 1 - Method ]#

Curve Method

	Philosophy

		-
			The curve method is a data map generation algorithm that may be applied to a data map
			curve model.
		-
	
	Principles

		Pre-Requisites

			-
				The curve mathod assumes a cleansed data map.
			-

		Steps

			Step One - Normalization

				-
					All points in the data map shall be normalized to have the same number of
					dimensions as the input value, either being cropped to the correct size or
					being padded with a padding value to match the correct size.
					
					Said padding value is by default zero.
				-

			Step Two - Selection

				-
					The N closest points to the input value shall be used to calculate the final
					value, where N is the number of dimensions of the input value.
					
					If the total number of available points is less than N, then all of them shall
					be used.
				-

			Step Three - Calculation

				-
					The distance between the closest point selected during step two to the input
					value and the input value itself shall be defined as the minimum.

					The final value shall be calculated as the sum of the values generated by
					passing each point selected during step two to the following function:

						f(point) =

							if(point = input[location]):
							
								1

							else if(minimum = 0):
							
								0

							else:
							
								(1 - (point[distance] / total[distance])) *
								(minimum / point[distance]) *
								point[value]
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 2 - Generation: 2 - Data Map Net ]#

Data Map Net

	Philosophy

		-
			A data map net is a neural network generated for a data map to be used in data map
			generation.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 3 - Vector ]#

Data Map Vector

	Philosophy

		-
			A data map vector is a list of data maps.

			If the same input vector is used to approximate an output for all of them, then the
			outputs may be combined into an output vector.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 3 - Vector: 1 - Synchronous Map ]#

Synchronous Map

	Philosophy

		-
			A synchronous map is a data map vector in which each data map has the same number of
			input-output pairs, with the same input vectors across each corresponding input-ouptut
			pair, while not necessarily sharing the same output values across each corresponding
			input-output pair.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 3 - Vector: 2 - Data Map Stack ]#

Data Map Stack

	Philosophy

		-
			A data map stack is a sequence of data map vectors where the output of one data map
			vector becomes the input for the next, where each of said vectors is referred to as a
			layer.
		-

	Principles

		Blackbox

			-
				A data map stack functions as a single data map vector from the perspective of any
				external systems where the first layer is the input and the last layer is the
				output.
			-

		Deep

			-
				Any data map stack consisting of four layers or more is considered deep.
			-

		Training

			-
				In training a data map stack, the process looks for the lowest amount of change it
				can make to the stack to achieve the desired results.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 4 - Reduction ]#

Data Map Reduction

	Philosophy

		-
			Data map reduction is the process of creating a model that may serve as a hueristic for
			a data map while being simpler to store, to process, or both.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 1 - Data Map: 5 - Binary Data Map ]#

Binary Data Map

	Philosophy

		-
			A binary data map is a data map where every number in the input vector as well as the
			output number can only be a zero or a one.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 2 - Binary Cropping ]#

Binary Cropping

	Philosophy

		-
			Binary cropping is a method for culling the output of operations where outputs are
			vectors of variable length containing numbers between zero and one, inclusive.
		-
	
	Principles

		Vector Set

			-
				When an input is received, it is passed to two separate operations, each of which
				returns a vector of numbers between zero and one.

				The first vector is called the value vector, the second vector is called the
				culling vector, and collectively they are referred to as a vector set.
			-

		Scaling

			-
				The length of the value vector should be equal to the length of the longest
				expected output value.

				The length of the culling vector should be equivalent to the number of binary
				digits in the shortest possible binary number where each digit is one, with a value
				equal to or greater than the length of the value vector.
			-

		Cropping

			-
				Once a vector set has been generated, the culling vector is interpreted to generate
				a binary number where the first number in the vector is the lowest binary digit,
				the last number in the vector is the highest binary digit, a number less than .5
				corresponds to a zero, and a number greater than or equal to .5 corresponds to a
				one.

				If the length of the value vector is greater than the value of the generated binary
				number, then the trailing end of the value vector shall be cropped such that the
				length of the value vector is equal to the value of the generated binary number.

				The value vector is then returned as the final result.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 3 - Gradient Vector ]#

Gradient Vector
	
	Philosophy

		-
			A gradient vector is a vector created by mapping the contents of a vector containing
			numbers between zero and one, inclusive, to a vector which may have a different length
			such that every number in the original vector has an influence on every value in the
			new vector, relative to their respective indicies.
		-
	
	Principles

		Coefficient

			-
				The following formula is used for calculating the coefficient used for multiplying
				the values of the original vector to produce the values of the new vector:
				
					1 - |(([Original Index] / [Original Size]) - ([New Index] / [New Size]))|
				
				The index values start at one, unless their corresponding length value is zero, in
				which case their value will be zero.
				
				If either of the length values are zero, then formula will be skipped and the
				coefficient will be set to zero to avoid a divide by zero error.

				After all the values have been calulated for a number in the output vector, the
				number used shall be the average of them.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 4 - Neural Network Refactoring ]#

Neural Network Refactoring

	Philosophy

		-
			Neural network refactoring is the act of altering the structure of a neural network to
			either increase or decrease its complexity while preventing it from producing a
			different output for any given input.

			Alternatively, to alter the structure of a neural network while allowing for a mimimal
			amount of alteration in it output for any given input is referred to as neural network
			pseudorefactoring.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 5 - Category Filter ]#

Category Filter

	Philosophy

		-
			An category filter uses an AI model to place into data into categories, after which a
			secondary AI model can pick the most appropriate output from within said category.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 5 - Category Filter: 1 - Autogenerated ]#

Autogenerated Expert System

	Philosophy

		-
			Expert systems can be automatically generated for uses in expert system filters from
			commonalities between items within a dataset sharing the same label.
		-

	Principles

		Generation

			Counting

				-
					The first step in autogenerating an expert system is to count how many items of
					each category possess certain properties.
				-

			Certainty Properties

				-
					If every item within a certain category possesses a certain property, then it
					is assumed that an item of said category must always possess said property,
					making said property a certainty property.
				-

			Secondary Certainty Properties

				-
					If every item within a certain category that possesses a certain property
					possesses another property, then it is assumed that an item of said category
					that possesses the former property must always possess the latter property,
					making the latter property a secondary certainty property.
				-

		Processing

			-
				A new input should be narrowed down to a certain subset of categories based on the
				certainty and secondary certainty properties that it possesses.
			-

		Ambiguity Testing

			-
				If autogenerating an expert system meant to feed into a system which uses
				pre-trained models, said models should be trained on groups of categories detected
				by running all training items through the certainty and secondary certainty
				categories to find all combinations of categories that occur when the ruleset is
				unable to narrow it down to one.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 1 - Utilities: 6 - Model Analyzer ]#

Model Analyzer

	Philosophy

		-
			A model analyzer tests the accuracy of mutliple AI models on a given dataset and ranks
			them according to their performance on said dataset.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 2 - Models: 1 - SOUL Core Variable Model ]#

SOUL Core Variable Model

	Philosophy
	
		-
			The SOUL core variable model is a model for the standard SOUL core where the output may
			be any vector of any length containing numbers between zero and one, inclusive.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 2 - Models: 2 - SOUL Core Classifier Model ]#

SOUL Core Classifier Model

	Philosophy
	
		-
			The SOUL core classifier model is a model for the standard SOUL core that correlates
			any output vector to one of a set of established possible output values.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 3 - Formats: 1 - SOUL Core Format ]#

SOUL Format

	Philosophy
		
		-
			The SOUL format allows standard SOUL to save its state as a ONE document.
			
			The document must have two elements: an element with the content "Corpus", and an
			element with the content "Models".
			
			For every input/output/correlation set in the SOUL's corpus, the corpus element must
			have a child with the content "Set". This child must have three children: an element
			with the content "Input", and element with the content "Output", and element with the
			content "Correlation". Each one of said elements must have a child with content
			containing its respective value.
			
			For every model the SOUL contains, it must have a child with content containing the
			model's name. Each such element must have a child with the state of its respective
			model encoded in said model's custom file format as its content.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 1 - Standard SOUL: 3 - Formats: 2 - Kaeon Neural Network Format ]#

Kaeon Neural Network Format

	Philosophy
	
		-
			The Kaeon Neural Network Format is a ONE document format for storing the state of a
			neural network.
		-
	
	Principles
		
		Structure
			
			-
				The document will contain an indefinite number of elements, each containing the
				content "Layer" or "Use".
				
				Elements with the content "Layer" correspond to a layer in a neural network. The
				order in which they are listed dictates the order of the layers in the neural
				network.
				
				Elements with the content "Use" may have an indefinite number of children, each
				with content specifying the name of a module containing various activation
				functions. Each of said activation functions will have a string alias.
				
				Nested within the layer elements will be an indefinite number of elements
				containing the content "Neuron", corresponding to neurons within their respective
				layer, listed in the order corresponding to their indexes. Each neuron element will
				have a combination of the following children: an element with the content
				"Connections", and element with the content "Bias", and an element with the content
				"Activation".
				
				The element with the content "Connections" must be present if the layer its
				respective neuron occurs in is not the last layer and must be absent otherwise,
				will have a child with containing a number between between zero and one for every
				neuron in the following layer, corresponding with the weights of the neural
				connections.
				
				The element with the content "Bias", if present, will have a child containing a
				number between zero and one, corresponding to the bias of the neuron. If the bias
				element is not present, the neuron will have a bias of zero. This element may not
				be present in a neuron belonging the first layer of the neural network.
				
				If an element with the content "Activation" is present among the children of a
				neuron element, it must have a child containing the alias of an activation function
				provided by one of the modules referenced by a use element. The referenced
				activation will be the activation function of the neuron defined by said neuron
				element.
				
				If an element with the content "Activation" is not present among the children of a
				neuron element, the neuron defined by said neuron element will have the following
				activation function:
				
					f(x) = 1 / (1 + e^-x)
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 2 - Standard SOUL Core ]#

Standard SOUL Core

	Philosophy
	
		-
			A standard SOUL core is a SOUL core implemented using a standard module which may only
			be connected to other modules using private connections.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 3 - SOUL Entity Conventions ]#

SOUL Entity Conventions

	Philosophy

		-
			This document specifies conventions for SOUL entities.
		-
	
	Principles

		Atlas

			-
				A SOUL entity atlas is a SOUL entity implemented as or as part of a philosopher's
				atlas.
			-

		Cluster

			-
				A SOUL entity cluster is a group of SOUL entities that for all intents and purposes
				function together as a single SOUL entity.
			-

		Organs

			Philosophy

				-
					SOUL entity organs are modules that interact with SOUL entities.

					They may either be internal, meaning they are part of the SOUL entity itself,
					or external, meaning they interface with the SOUL entity through its input and
					output channels.
				-

			Principles

				Internal

					Pulse

						-
							A pulse is an internal SOUL entity organ that manages an internal event
							loop where upon each iteration other internal SOUL entity organs,
							called pulse modules, may send text through the output channels.
						-

					Record

						-
							A record is an internal SOUL entity organ that stores records of the
							text inputs received, text outputs sent, and numerical inputs received
							by the SOUL entity it belongs to along with the time they were sent or
							received.
						-

					Pulse Modules

						Starter

							-
								A starter is a pulse module that produces randomized output to
								send through the output channel when insufficient data is
								available within whatever records are available.
							-

						Core

							-
								A core is a pulse module that produces output to send through the
								output channel based on the content of whatever records are
								available is said said contents are sufficent.
							-

				External

					Manager

						-
							A manager is an external SOUL entity organ that allows a user to modify
							the state of a SOUL entity, to record the state of a SOUL entity and
							export it to text, to start, pause, or stop the activity of a SOUL
							entity, or to spawn and destroy SOUL entities.
						-

					Breeder

						-
							A breeder is a module that can take the serialized state of a SOUL
							entity and mutate it in order to emulate breeding.
						-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 3 - SOUL Entity Conventions: 1 - SOUL Entity Exploit ]#

SOUL Entity Exploit

	Philosophy

		-
			A SOUL entity exploit is a flaw in the anatomy or environment of a SOUL entity that
			allows it to obtain high amounts of positive feedback without doing what it is intended
			to do.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 2 - SOUL: 3 - SOUL Entity Conventions: 2 - Artifical Imagination ]#

Artificial Imagination

	Philosophy

		-
			An artificial imagination is a simulation that exists within an artifically intelligent
			application that allows it to simulate performing certain actions and to observe its
			own predictions about the effects of said actions.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 3 - Aether ]#

Aether

	Philosophy
	
		-
			Aether is a system that allows the interface of a regulated Philosopher's Stone module
			to be attatched to modules that exist within systems running in entirely different
			environments.
		-
	
	Principles
	
		Alias
		
			-
				An Aether module may be identified via a unique string alias or path.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 3 - Aether: 1 - Standard Aether ]#

Standard Aether
	
	Philosophy
		
		-
			Standard Aether is a variant of the Aether system under which Aether modules shall be
			standard modules.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 3 - Aether: 2 - Global Retrieval ]#

Global Retrieval

	Philosophy

		-
			Global retrieval is when Philosopher's Retrieval is used to retrieve a set of files
			and directories from within a specified directory, where the path or content of said
			files and directories matches a given regular expression.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 3 - Aether: 3 - Philosopher's Core ]#

"Philosopher's Core"

	Philosophy

		-
			A Philosopher's Core is an online Philosopher's Cross with the internal structure of a
			ONE document, that may be interfaced with through HTTP calls.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 1 - Core: 2 - Philosopher's Stone: 3 - Aether: 4 - Aether Atlas ]#

Aether Atlas

	Philosophy

		-
			An Aether Atlas is an autonomous network of devices and applications that can
			dynamically retructure itself.

			As such, an aether atlas can be represented in abstract form as a Philosopher's Atlas.
		-

	Principles

		Aether Node

			-
				An Aether Node is an application or device designed to function as part of an
				Aether Atlas.
			-

		Aether Utility

			-
				An Aether Utility is an application or device that was not designed to function as
				part of an Aether Atlas but which has nonetheless been incorporated into at least
				one.
			-

		Aether Clusters

			-
				Aether Clusters are Aether Atlases within Aether Atlases.
			-

		Aether Union

			-
				An Aether Union is a related but unconnected group of Aether Atlases.
			-

		Aether Interface

			-
				An Aether Interface is a device or application that provides a user interface to an
				Aether Atlas.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 1 - Utilities: 1 - Time Based Random Numbers ]#

Time Based Random Numbers

	Philosophy

		-
			If a machine lacks specialized circuitry for generating hardware random numbers, then
			random numbers generated by using the time as specified by the machine's clock as a
			seed can be used as a substitute.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 1 - Utilities: 2 - AI Rendering ]#

AI Rendering

	Philosophy

		-
			AI Rendering is the act of rendering scene geometry through a machine learning model
			either instead of through a graphics processor or before or after running it through a
			graphics processor.
		-

	Principles

		Prudent Rendering

			-
				Prudent rendering is a process where a renderer for a pre-rendered scene determines
				which sets of frames repeat exactly or can be derived from a single frame and thus
				avoids rendering certain frame unnecessarily.
			-

		Prudent Playback

			-
				Prudent playback is when frames that repeat exactly in a sequence are stored only
				once, and the playback seuqence itself is stored as a sequence of references to
				said frames.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 1 - Utilities: 3 - Virtual Hardware ]#

Virtual Hardware

	Philosophy

		-
			Virtual hardware is a simulation of a given physical machine that software may interact
			with in the same manner that it would the real equivalent.
			
			Among other things, this would allow one to conserve the resources needed to build said
			machine at least until said resources are availble and the concept has been
			sufficiently proven.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 1 - Dynamic Bits ]#

Dynamic Bit

	Philosophy

		-
			A dynamic bit is a value that can be used as a bit in a vitrual circuit.

			Dynamic bits may be of any type, and can be interpreted, either alone or in groups, to
			either produce a new value of any type or to produce a boolean value. Any operation
			used to do this must do so determinisitcally.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 1 - Dynamic Bits: 1 - Standard Dynamic Bit ]#

Standard Dynamic Bit

	Philosophy

		-
			A standard dynamic bit is a list of numbers between zero and one, inclusive, where zero
			represents a false value and one represents a true value. Said list must have at least
			one element.

			By default, the length of said list is one.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 1 - Dynamic Bits: 2 - Gateway Philosopher's Medium ]#

Gateway Philosopher's Medium
	
	Philosophy
	
		-
			A module that abides by the gateway Philosopher's Medium shall contain a function
			referred to as the gateway function that shall take a dynamic bit and deterministically
			return a new value based on the passed in value, as well as a function referred to as
			the reduce function that shall take a dynamic bit and deterministically return a
			boolean value based on the passed in value.

			A module that abides by the gateway Philosopher's Medium shall be known as a gateway
			Philosopher's Stone module.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 2 - Dynamic Lists ]#

Dynamic List

	Philosophy

		-
			A dynamic list is a list in which each index may have a string alias.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 2 - Dynamic Lists: 1 - Dynamic List Format ]#

Dynamic List Format

	Philosophy

		-
			The dynamic list format is a standard for encoding a dynamic list as a non dynamic
			list, where every odd numbered item is an element alias, and every even numbered item
			is a list element assigned to the alias immediately preceding it.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 2 - Dynamic: 3 - Dynamic Web ]#

Dynamic Web

	Philosophy

		-
			The dynamic web is the set of websites that can be dynamically constructed from
			statically accessible assets on the internet.
		-

	Principles

		Resource Encoding

			-
				Resource encoding is the process of encoding the source for a given resource in a
				different type of file that would normally be used in order to bypass obstacles
				that would otherwise hinder its use.

				One type of resourse encoding, called CORS bypass encoding, is to encode text in an
				audio or visual resource and to then extract said text from said resource in order
				to bypass CORS restrictions without using a CORS proxy. One of the simplest ways to
				do this, which can be called bitmap bypassing, would be to use the RGB values in a
				bitmap to encode the source text.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 3 - Common: 1 - Common Object ]#

Common Object

	Philosophy

		-
			A common object is a specification for the data structure needed to represent a given
			type of object, such that it may be implmented in different languages and environments.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 3 - Common: 1 - Common Object: 1 - Common Document ]#

Common Document

	Philosophy

		-
			A common document is a specification for the data structure needed to represent a given
			type of document, such that it may be implmented in different languages and
			environments.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 3 - Common: 2 - Common Framework ]#

Common Framework

	Philosophy

		-
			A common framework is a framework that provides an interface for constructing an
			application such that the application may be recreated in other frameworks.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 3 - Common: 3 - Common ID ]#

Common ID

	Philosophy

		-
			The common ID conventions specify rules for applying tags to virtual objects such that
			they may be identified within it.

			Under the common ID conventions, any object may have an indefinite number of string
			tags, which shall be insensitive to letter case and to whitespace.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 3 - Common: 4 - Common Convention ]#

Common Convention

	Philosophy

		-
			A common convention is a convention for multiple technologies which, if followed, allow
			each of said technologies to operate seamlessly together.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 4 - Modules: 1 - Shadow Module ]#

Shadow Module

	Philosophy

		-
			A shadow module is a module that is attached to a pre-existing module referred to as
			the host module.

			A shadow module will dynamically modify its host module at runtime. A unit of code that
			is inserted into a host module to act as a interface to a shadow module is called a
			shadow point.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 4 - Modules: 2 - Ghost Module ]#

Ghost Module

	Philosophy

		-
			A ghost module is a module with functioning endpoints but incomplete implementation.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 4 - Modules: 3 - Portal Module ]#

Portal Module

	Philosophy

		-
			A portal module is a module in which the state shall be modified to represent the state
			of another module, and may alter the state of the module it represents if its own state
			is modified.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 4 - Modules: 3 - Portal Module: 1 - ACE Portal ]#

ACE Portal

	Philosophy

		-
			An ACE Portal is a module that serves as a portal module to all or part of an ACE
			document.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric ]#

Geometric Automata

	Philosophy

		-
			Geometric automata is an umbrella term for computational processes that simulate some
			geometric in which, as time passes, the states of various points in said space may
			change according to some set of rules.

			Cellular automata is a form of geometric automata.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric: 1 - Continuous ]#

Continuous Automata

	Philosophy

		-
			Continuous automata is a form of geometric automata in which the points in the
			geometric space whose states may be affected are not discrete.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric: 2 - Multistate ]#

Multistate Automata

	Philosophy

		-
			Multistate automata is a form of geometric automata in which there are more than two
			states that may be assigned to given points in space.
		-

	Principles

		Infinite State Automata

			-
				Infinite state automata is a form of multistate automata in which there is an
				indefinite number of states that may be assigned to given points in space.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric: 3 - Multidimensional ]#

Multidimensional Automata

	Philosophy

		-
			Multidimensional automata is a form of geometric automata in which the space in which
			the simulation takes place operates in at least three dimensions.
		-

	Principles

		Subdimensional Automata

			-
				Subdimensional automata is a form of geometric automata in which the space in which
				the space in which the the simulation takes place operates in either zero or one
				dimensions.
			-

		Varying Dimensonal Automata

			-
				Varying dimensional automata is a form of geometric automata in which the
				simulation takes place in a verying dimensional space.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric: 4 - Warping ]#

Warping Automata

	Philosophy

		-
			Warping automata is a form of geometric automata in which the simulation takes place in
			a dynamic space.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 1 - Geometric: 5 - Chaotic ]#

Chaotic Automata

	Philosophy

		-
			Chaotic automata is a form of geometric automata in which the state of a point in the
			space in which the simulation takes place may, when the rules gives multiple
			possibilities for valid states, change to one of the valid options arbitrariliy.
		-

	Principles

		Bias

			-
				Certain factors may influence the odds of an otherwise entirely arbitrary
				selection.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 2 - Concepts: 5 - Theoretical: 1 - Automata: 2 - Dynamic ]#

Dynamic Automata

	Philosophy

		-
			Dynamic automata is an umbrella term for automata processes in which the rules that
			govern the simulation may change over time.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Databases: 1 - ONE Database ]#

ONE Database

	Philosophy

		-
			A ONE database is a database that stores data in a ONE document structure.
		-

	Principles

		Relational Databse Implementation

			-
				A ONE database can be emulated using a single relational database table wherein
				every record represents an element, and where each record has five columns.

				The ID column, of type integer serial, specifies a unique ID for each element,
				where said ID is greater than one, and serves as the identifying column.

				The content column, of type string or text, specifies the string content of each
				element.

				The parent column, of type integer, specifies the ID of each element's parent
				element, and if the element has no parent, it shall contain zero.

				The index column, of type integer, specifies the index of each element parent among
				its parent's children starting at one, and if the element has no parent, it shall
				contain zero.

				The metadata column, of type string or text, specifies additional metadata
				regarding each element.

				Additionally, the database may be set up such that the data is spread across
				multiple tables, in which case information about the relationships between said
				tables shall be encoded within the content of the metadata column, and a single
				table within the database shall serve as the root or master table.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Databases: 2 - Common Database API ]#

Common Database API

	Philosophy

		-
			The common database API is a standard for the parameters of a function that can take
			and process any request for any type of database.
		-

	Principles

		Default Name

			-
				The defualt name of the common database API function is "query".
			-

		Parameters

			Sources

				-
					The sources parameter is either a single value or a list of values that
					specify databases that the requests are directed at.

					Each of said values may either be a string specifying the database, or a list
					where the first element is said string and the second element, if present, is
					a list of lists where in each of said nested lists, the first element is a
					string specifying the name of a credential and the second is a string
					containing the value of a credential.
				-

			Requests

				-
					The requests parameter is either a single value or a list of values that
					constitute requests directed at the intended databases.
				-

			Type

				-
					The type parameter, which is optional, is a string that specifies the type of
					database the requests are intended for.

					If the type parameter is not present, the API may attempt to dynamically
					accommodate the request.
				-
		
		Standard Types

			Relational
			Key
			Document
			Column
			Graph

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Databases: 3 - Virtual File System ]#

Virtual File System

	Philosophy

		-
			A virtual file system is a vitual interface to an indefinite number of file storage
			systems.

			Each of said systems shall have an alias.
		-

	Principles

		Resource Paths

			-
				Each file storage system managed by a virtual file system shall be treated as a
				disk, and every resource therein shall either be a file or a folder, with disks in
				said systems being treated as folders.

				Given the afoemention conventions, a path for a resource within a virtual file
				system shall follow the format of a UNIX style path.
			-

		Get Resource Function

			-
				Each file storage system interface within a virutal file system shall have a get
				resource function, which shall take an absolute path not including the disk and,
				for a file, shall return its content, and for a folder, shall return an array
				containing two arrays, the first containing the aliases of all of the sub folders
				in said folder and the second containing all of the aliases of the files in said
				folder.
			-

		Set Resource Function

			-
				Each file storage system interface within a virutal file system shall have a set
				resource function, which shall take an absolute path not including the disk and,
				for a file, a string, for a folder, an object representation of a folder and its
				contents, and to delete an existing resource, a null value, and shall place the
				specified resource at the specified location and shall overwrite any existing
				resource sharing the same path.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Documents: 1 - Printable DOM ]#

Printable DOM

	Philosophy

		-
			A printable DOM document, or PDOM document, uses existing HTML specification to form an
			open and simple standard for encoding the content of a multi-page printable document.
		-

	Principles

		Structure

			-
				A printable DOM document is represented as a list of objects, each of which
				represents a page in said document, ordered according to their order in the
				document.
				
				Each object page object contains the virtual pixel dimensions of the page so as to
				callibrate the size of content scaled by pixels and to specify the shape of the
				page.

				Each page object shall also contain the DOM of an HTML document, which shall
				specify its content.
			-

		Standards
		
			Encoding

				-
					The standard method of encoding a PDOM document in as a JSON document, where a
					JSON list serves as the container of the document, and where each page object
					within it is represented as a JSON object.

					Each page object shall thus have three fields, a number field for each the of 
					the virtual pixel dimensions with the keys "width" and "height" respectively,
					and a string field with the key "content" containing the DOM content of the
					page as a DOM JSON string.
				-

			File Extension

				-
					The standard file extension for a PDOM document is ".pdom".
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Documents: 2 - Standard Repository ]#

Standard Repository

	Philosophy

		-
			The standard repository is a convention for project repositories.
			
			Under the convention, project repositories should contain one folder sharing the name
			of the repository, in which all of the project contents are kept. Alongside said
			folder, there may also be a license file and a readme file.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Applications: 1 - Standard Service ]#

Standard Service

	Philosophy

		-
			A standard service is a back end application that, if run with no additional command
			line arguments, shall start up a web API that may be interfaced with via HTTP calls,
			and if run with additional command line arguments, may perform any miscellaneous
			action.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Applications: 2 - Minimal API ]#

Minimal API

	Philosophy

		-
			A minimal API is a service that receives http and https requests, and performs tasks
			and returns data based solely on the content of the request's URL.
		-

	Principles

		Default Header

			-
				By default, requests to minimal APIs should use GET headers, though effects of said
				requests may be anything.
			-

		Minimal API Wrapper

			-
				A minimal API wrapper is a utility that automatically handles tasks that require
				multiple minimal API calls.

				This may be necessary in cases involving encryption or where large amounts of data
				need to be exchanged.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Applications: 3 - Shadow Host ]#

Shadow Host

	Philosophy

		-
			A shadow host is a website that takes the URIs of existing resources or the literal
			content of resources as arguments through its own URI and renders said resources as a
			new website.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Systems: 1 - Virtual System ]#

Virtual System

	Philosophy

		-
			A virtual system is a virtual interface to a system that contains a modular list of
			commands, each of which have an alias and may take an indefinite number of string
			arguments.

			A virtual system may use various different UI shells as interfaces to it, and may
			execute commands autonomously upon startup.
		-

	Philosophy

		Default Virutal System

			-
				A default virtual system provides an interface to a virtual file system through its
				commands, provides unix style commands for file system navigation and management,
				provides commands for dynamically changing the available commands, as well as for
				dynamically changing the shell in use.

				If the name of a file is used as a command, it shall run as an executable if it is
				an executable.
				
				The default shell for a default virtual system is a multi-tabbed terminal
				interface.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Systems: 2 - Game Recorder ]#

Game Recorder

	Philosophy

		-
			A game recorder is a module for a game engine that, while a game engine is running a
			game, records each rendered frame as an image.

			As such, the scene's physics and scripts should be updated at a fixed rate per rendered
			frame.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Systems: 3 - Standard UI Conventions ]#

Standard UI Conventions

	Philosophy

		-
			The standard UI conventions are a set of conventions for handling GUIs and user
			input in applications.
		-

	Principles

		GUI

			2D Central Dimensions

				-
					Under the standard UI conventions, the dimensions of 2D GUI items are to be
					specified according to a coordinate system where the center of the reference
					area is the origin and the edges of the reference area are positive or negative
					one.

					If an aspect ratio is to be maintained, the smaller of the reference area
					dimensions, those being the width and the height, shall define a measurement of
					two units which shall apply to both dimensions.

					3D properties may be applied to 2D objects for pseudo-3D effects.
				-

			Transforms

				-
					Under the standard UI conventions, the position, orientation, and size of GUI
					items are to be specified using a stacked series of transforms, which shall
					include translations, rotations, and scales.
					
					Translations and scales are to be defined using 3D vectors, 2D rotations are to
					be defined using either scalars that represent rotation on the Z axis for
					normal 2D rotation, or quaternions for pseudo-3D effects, and 3D rotations are
					to be defined using quaternions.
				-

			Standard Asset Size

				-
					The default size of any object should be defined such that, in keeping with its
					default proportions, the vector defined by its lengths in all relavent
					dimensions should have a magnitude of one.
				-

		Input

			-
				Under the standard UI conventions, there is to be a global index specifying the
				current positions and held buttons of all input devices.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Processes: 1 - Dynamic Dependency Retrieval ]#

Dynamic Dependency Retrieval

	Philosophy

		-
			Dynamic dependency retrieval is a convention wherein a programming environment shall
			dynamically install any external dependencies required by programs running within it if
			they are not installed already.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Processes: 2 - Polyglot Call ]#

Polyglot Call

	Philosophy

		-
			A polyglot call is an operation which, from one language or envrionment, dynamically
			executes an operation in another, and returns the result to whatever it was called
			from.
		-

	Principles

		Types

			Command

				-
					A command polyglot call takes a string specifying a terminal command, executes
					it, and returns the contents of stdout upon its completion.
				-

			Compile

				-
					A compile polyglot call takes a string specifying the code for a program
					written in a different language, and may optionally take a list of string
					arguments for said program.

					It dynamically interprets or compiles said code, runs the resulting program
					with the provided arguments if there are any, and then returns the contents of
					stdout upon its completion.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 4 - Bots: 1 - Scout Bot ]#

Scout Bot

	Philosophy

		-
			A scout bot is a web scraper bot designed to use existing search engines in order to
			gather information on a given topic and produce analytics on it.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 4 - Bots: 2 - Report Bot ]#

Report Bot

	Philosophy

		-
			A report bot is a bot that manages scout bots and uses information gathered and
			produced by them to generate qualitative reports on a given topic.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 4 - Bots: 3 - Operations Bot ]#

Operations Bot

	Philosophy

		-
			An operations bot is a bot that manages report bots and uses reports generated by them
			in order to automate other tasks.
		-

	Principles

		Operations Bot Net

			-
				An operations bot net is a network of operations bots designed to automate a suite
				of tasks while taking directives from external operators.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 3 - Architecture: 1 - Kaeon Architecture ]#

Kaeon Architecture

	Philosophy

		-
			Kaeon Architecture is a system for constructing modules in a manner that maximizes
			modularity and fault tolerance.

			A module designed using the Kaeon architecture is referred to as a Kaeon module.
		-
	
	Principles

		Utilities

			-
				Utilities are functions and modules that are publicly available and statically
				accessible.
			-

		Processes

			-
				Processes are persistenly running modules that serve solely to govern the calling
				of functions within utilities.
			-

		Network

			-
				A module designed using the Kaeon architecture is formed of a group of modules
				connected together in a Philosopher's Atlas.
			-

		Data

			-
				All data stored by a module designed using the Kaeon architecture should be stored
				in internal or external databases that are globally accesible to the utilities.
			-

		Layers

			-
				The network of a module designed using the Kaeon architecture shall be spearated
				into two sections: the application layer for processing the internal logic of the
				module, and the interface layer for communicating with external modules.
			-

		Core

			-
				The network of a module designed using the Kaeon architecture may have a single
				module placed between the application layer and the interface layer of the network
				known as the core module, which if present shall serve as a reference point for the
				whole module.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 3 - Architecture: 2 - FUSION Interpreter Architecture ]#

FUSION Interpreter Architecture

	Philosophy
	
		-
			The FUSION interpreter architecture dictates the ideal way to implement FUSION using a
			Philosopher's Atlas.
		-
	
	Principles
	
		FUSION Core

			Philosophy
			
				-
					A FUSION core is a standard module that manages the FUSION process. It will
					have the tag "FUSION", and will contain a boolean flag called "running" that
					indicates whether the process or internal process functions are currently
					running.
				-

			Principles
				
				On Call
				
					Update
					
						-
							If a FUSION core receives a packet with the string "Update" as its
							first element, it will scan the Philosopher's Atlas to see if any
							FUSION units have been added or removed.
						-
				
					Stop
					
						-
							If a FUSION core receives a packet with the string "Stop" as its first
							element, it will stop the process and internal process functions if
							either of them are running.
						-
				
				Functions
				
					Process
					
						-
							The process function takes a ONE element as an argument, sets the
							running flag to true, calls the internal process function using the
							passed in element and the boolean true, then flushes the state and sets
							the running flag to false.
						-
				
					Internal Process
					
						-
							The internal process function takes a ONE element and a boolean value
							that signifies whether it was called from the process function or not
							as arguments, sets the running flag to true, and performs the FUSION
							process on the passed in element. The internal process function should
							prevent itself from crashing in the event that any of the FUSION unit
							functions crash.
						-
				
					Tick

						-
							The tick function takes an object containing the current state of a
							FUSION process, performs a single iteration of said process, updating
							said state accordingly, and then returns said state.
						-

					Get Threads

						-
							The get threads function returns the root elements of all threads
							currently being processed, which shall have fields containing the
							metadata for said threads.
						-

					Get Thread

						-
							The get thread function takes an element and returns its nearest
							ancestor currently being processed as a thread.
						-

					Add Thread

						-
							The add thread function takes an element to begin processing in a new
							thread using the fusion process.
						-

					Set Thread

						-
							The set thread function takes an element and a boolean, pausing the
							thread that said element is being processed on if said boolean is true,
							and unpausing it if false.
						-

					Remove Thread

						-
							The remove thread fucntion takes an element and terminates the thread
							processing said element.
						-

					Push Thread

						-
							The push thread takes two elements, and pushes the second element as a
							subroutine onto the stack of the thread currently processing the first
							element.
						-

					Pop Thread

						-
							The pop thread takes two elements, and pushes the second element as a
							subroutine onto the stack of the thread currently processing the first
							element.
						-
		
		FUSION Unit

			Philosophy
				
				-
					All FUSION commands, along with certain other functionality should be
					implemented as FUSION Units, which are standard Philosopher's Stones and
					attached to the Philosopher's Atlas containing the relevant FUSION cores.
					
					They shall have the tag "FUSION Unit".
				-

			Principles
			
				Functions
				
					Deny
					
						-
							The deny function is the first function to be called when acting upon
							an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if true will
							prevent all other FUSION units from acting on this element until FUSION
							has moved to a different element.
							
							It returns false by default.
						-
				
					Verify
					
						-
							The verify function is the second function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if false will
							prevent the FUSION unit it belongs to from acting on the passed in
							element until FUSION has moved to a different element.
							
							It returns false by default.
						-
					
					Trickle Down
					
						-
							The trickle down function is the third function to be called when
							acting upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if false will
							prevent FUSION from trickling down to the element's children.
							
							It returns true by default.
						-
					
					Process
					
						-
							The process function is the fourth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns an object.
							
							It returns null by default.
						-
					
					Terminate
					
						-
							The terminate function is the fifth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns a boolean
							that if true will stop the FUSION process.
							
							It returns false by default.
						-
					
					Is Added
					
						-
							The is added function is the sixth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns a boolean
							that if false will prevent the object generated by the process function
							from being placed into the list of objects that will be used as an
							argument for the process function when FUSION bubbles up to the
							element's parent.
							
							It returns true by default.
						-
					
					Jump
					
						-
							The jump function is the seventh function to be called when acting upon
							an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and may either return
							a ONE element, in which case the FUSION process will jump to said
							element, or a null value.
							
							It returns null by default.
						-
					
					Handle Error
					
						-
							The handle error function will only be called if any of the other
							functions encounter an error.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children, and an error message as arguments.
							
							It does not return a value.
						-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 3 - Architecture: 3 - Kaeon ACE Interface Architecture ]#

Kaeon ACE Interface Architecture

	Philosophy
	
		-
			A Kaeon ACE Interface is a middleware application that interprets a Kaeon ACE document
			and renders its content to a specific platform.
		-
	
	Principles

		Platforms

			-
				Given the nature of Kaeon ACE documents, the platforms that Kaeon ACE is rendered
				to will usually be game engines.
			-

		Philosopher~'s Atlas

			-
				A Kaeon ACE Interface will be embedded into a Philosopher's Atlas running within
				the platform that the content is being rendered to.
			-

		Core

			-
				A Kaeon ACE interface shall store a "core" object which shall serve as a bus to
				various parts of the interface.

				It shall contain, among other things, and object representation of the component
				entity tree described by the source document, as well as references to key
				components of the host platform and to the Philosopher's Atlas in which the
				interface is embedded.

				It shall itself be a node within the Philosopher's Atlas that the interface is
				embedded within.
			-

		Modules

			-
				The functionality of a Kaeon ACE interface shall be embedded within nodes, called
				Kaeon ACE modules, connected to the Philosopher's Atlas in which said interface is
				embedded.

				Each module shall have the tag "Kaeon ACE".

				Each module may have any combination of the Kaeon ACE module functions.
			-

		Entity Object

			-
				An entity object shall contain two lists, one being a list of its child entity
				objects, and the other being a list of its component objects, which may be of any
				type, and shall contain a reference to its parent entity.

				The core node shall contain a reference to an entity object which shall serve as
				the root of the engine's entity tree.
			-

		Module Functions

			On Call

				-
					The on call function takes the core node and a string as arguments.

					It may perform any action based on its arguments and may either return a string
					or a null value.

					By default, the string should be a ONE+ document.

					It may be called manually at any time.
				-

			On Default

				-
					The on default function takes the core node as an argument.

					It is called when the engine first detects the module's presence and may
					perform any operation.
				-

			On Deserialize

				-
					The on deserialize function takes the core node, a ONE element that corresponds
					to a Kaeon ACE component, and an entity object as arguments.

					It is called when the engine deserializes the source Kaeon ACE document for
					each component element, where said component element is the passed in ONE
					element, and may perform any operation and modify the content of the entity
					object, which corresponds to the entity that the component belongs to.
				-

			On Entity

				-
					The on entity takes the core node, an entity object, and a time delta value as
					arguments.

					It is called once per engine tick for every entity in the entity tree, where
					said entity is the passed in entity object, and where the passed in time delta
					value is the time that has passed since the last engine tick.
				-

			On Serialize

				-
					The on serialize function takes the core node and a component object as
					arguments.

					It may be called manually at any time, and shall either a Kaeon ACE ONE
					representation of said object in ONE list form, or shall return a value of
					null.
				-

			On Update

				-
					The on entity takes the core node and a time delta value as arguments.

					It is called once per engine tick, where the passed in time delta value is the
					time that has passed since the last engine tick.
				-

		Actions

			Calling

				-
					To call a Kaeon ACE interface is to take a string and to pass it to the on call
					function in every Kaeon ACE module in said interface, and to return all of the
					strings returned by said calls as a list.
				-

			Serializing

				-
					To serialize a Kaeon ACE application is to take every entity in its entity tree
					the their components and to render their properties to a Kaeon ACE document
					such that if said document were used as the source for another Kaeon ACE
					application, it would produce the same application with the properties of the
					serialized application at the time it was serialized.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Universal Hardware API ]#

Universal Hardware API

	Philosophy

		-
			The universal hardware API is a protocol designed to allow programmers to communicate
			with IoT devices solely through HTTP calls.
		-

	Principles

		Protocol

			-
				When a device that follows the protocol is turned on, it shall connect to a
				network, and shall host a single web server at a domain and port number hard coded
				into said device.

				The web server shall manage a service that may be used to control the device
				through HTTP requests.
			-

		Conventions

			Documentation

				-
					An HTTP GET request to the base route of the server of a device that follows
					the protocol should return a string containing a document file specifying the
					routes provided by said device's server.
				-

			Autonomous Behavior

				-
					A device that follows the protocol may act autonomously or according to other
					stimuli when not being directly controlled via HTTP calls.
				-

			Modification

				-
					Ideally, a device that follows the protocol should have some sort of secure
					mechanism in place to manually override its hard coded settings.
				-

			Security

				-
					A device that follows the protocol may restrict the use of some or all of its
					functionality to specific users, who must provide credentials to prove their
					identity.
				-

			Cellular

				-
					Ideally, the network that a device that follows the protocol connects to should
					be a cellular network.
				-

			Search

				-
					A device that follows the protocol may make itself publicly discoverable via
					certain search engines.
				-

			Acronym

				-
					The universal hardware API can be referred to as UHAPI ("you-happy") for short.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript ]#

United JavaScript

	Philosophy

		-
			United JavaScript is a set of conventions for JavaScript that enhance its compatibility
			between different environments as well as its ease of use.
		-

	Principles

		CommonJS Conventions

			-
				Under United JavaScript, regardless of the environment it is running in, JavaScript
				may use the CommonJS require function to dynamically load modules and to execute
				scripts.

				The modules passed to it must follow the CommonJS format.

				United JavaScript shall provide dynamic dependency retrieval for modules installed
				via package managers.

				The CommonJS require function's path parameter may be either a path on the
				local system or a URL to an online resource.
				
				The require function may take an optional second argument in the form of an object.
				Said object may have the fields "async", "dynamic", "global", and "reload".

				The async field, if present, shall contain either a function, a boolean, or a null
				value. If a function or a boolean is provided, it shall indicate that the require
				function is to execute asynchronously.
				
				If a function is provided for the async field, then upon the loading of the module,
				the specified function shall be called with the returned module as its first
				argument.
				
				If a boolean value of true is provided for the async field, then shall return a
				promise which shall resolve to the specified module once it has loaded.

				The dynamic field, if present, shall indicate that the path argument specifies the
				raw code of the module as opposed to a path to it. As such, any module loaded this
				way shall not be stored in the require function's cache.

				The global field, if present, shall indicate that the module is to be processed in
				the global scope. This can be used for loading and executing scripts.
				
				The reload field, if present, shall contain a boolean which, if true, shall
				indicate that the module specified by the path parameter is to be deleted from the
				cache and reloaded.
			-

		Asynchronous Conventions

			-
				Under United JavaScript, the await operator may be used at the root level of the
				main file, outside of async functions.
			-

		Execution Conventions

			-
				Under United JavaScript, a JavaScript file may be executed on the client side on
				its own without being explicitly tied to an HTML document.

				Furthermore, prior to interpretation, the Universal Preprocessor shall be applied
				to both the code of the main file and to any code loaded through the require
				function.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 1 - Conventions: 1 - List Object Equivalence ]#

List Object Equivalence

	Philosophy

		-
			List object equivalence is a JavaScript convention that allows any object to be
			interpreted as a list by taking the values of every field and ordering them in the
			order of their respective keys, and allows any list to be interpreted as an object by
			making each element a field value with the keys of said field being the respective
			indicies.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 1 - Conventions: 2 - United JavaScript Modules ]#

United JavaScript Modules
	
	Philosophy
		
		-
			A United JavaScript module is a CommonJS module where the exports are different for
			certain platforms. The aliases of the contents each platform specific variation of said
			exports must be the same, but their implementations may differ.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 1 - Conventions: 3 - HTJS ]#

HTJS

	Philosophy

		-
			HTJS is a convention that allows a single text file to act as both a JavaScript file
			and an HTML file through a strategic placement of JavaScript comments.
		-

	Principles

		Structure

			-
				HTML content and JavaScript content must be placed on separate lines.
				
				JavaScript content must be placed within script tags and HTML content must be
				commented out using JavaScript comments.
			-

		Conventions

			File Extension

				-
					A HTJS file should have a ".html" file extension.
				-

			Comment Mark Clearing

				-
					The JavaScript code may employ DOM modification code to clear the rendered HTML
					page of any JavaScript comment marks.
				-

			Standard Format

				-
					The standard format for a HTJS file begins with the line:

						// <script> document.documentElement.innerHTML = "";

					and ends with the line:

						// </script>

					with JavaScript code placed between the two aforementioned lines.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 1 - JSON Dynamic List ]#

JSON Dynamic List

	Philosophy

		-
			A JSON document may be converted to a dynamic list.
		-

	Principles

		Objects

			-
				A JSON object shall be converted to a dynamic list where each field becomes an
				element in said list, with the value of the field being the element, the position
				of the field being the index, and the alias of the field being the alias of the
				element.
			-

		Lists

			-
				A JSON list shall be converted to a dynamic list where each element has an alias of
				null.
			-

		Nesting

			-
				Nested lists and objects shall by default be converted into dynamic lists
				themselves.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 2 - JSON Dialects: 1 - United JSON ]#

United JSON

	Philosophy

		-
			United JSON is a file format in which a document shall contain one JavaScript object or
			array literal, written either in JSON or in vanilla JavaScript syntax, with both
			JavaScript comments and nested JavaScript function and API calls allowed.
		-

	Principles

		File Extension

			-
				United JSON files should use the file extension ".ujs".
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 2 - JSON Dialects: 2 - ONE JSON ]#

ONE JSON

	Philosophy

		-
			ONE JSON is a convention that allows for a ONE document to correspond to a JSON
			document.
		-

	Principles

		Objects

			-
				Any element with the content "object" shall correspond to a JSON object.

				Every child of said element, which may have either one child or no children, shall
				correspond to a field of the object, where the content of the element is the alias
				of the field, and its child, if it has one, shall correspond to its value.

				If a field element has no child, it shall have a value of null.
			-

		Lists

			-
				Any element with the content "list" shall correspond to a JSON object.

				Every child of said element shall correspond to a field of the list.
			-

		Literals

			-
				Any element with any content other that "object" or "list" shall correspond to
				literals.

				The content of the element shall define said literal, and must follow the JSON
				format for said literal.

				However, literal new lines and tabs may appear in string literals, and will
				corrspond to "\n" and "\t" respectively.

				Furthermore, a string literal does not have to be encased in quotation marks except
				to differentiate it from other types of values.
			-

		Letter Case and Whitespace

			-
				Letter case, as well as leading and trailing whitespace, shall not be taken into
				account for anything other than string literals.
			-

		Root Objects

			-
				If the root element has multiple children, then the document shall correspond to a
				list of all of the values that said children correspond to, arranged in the same
				order as their placement in the source document.

				If the root element has no children, then the document shall correspond to a null
				value.

				If the root element has one child, then the document shall correspond to the value
				that said child corresponds to.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 1 - Field JSON ]#

Field JSON

	Philosophy

		-
			A field JSON object is a JSON object where every field value is a string.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 2 - Function JSON ]#

Function JSON

	Philosophy

		-
			A function JSON object is a JSON object that corresponds to a function.

			A function JSON object must have a field with the key "functionJSON" and the value
			true.
			
			The function itself shall be defined according to field with the key "code", containing
			a string specifying said code, which may or may not include the definition.

			If the definition is included in the function code, the body of the function must be
			nested under the definition, but the definition does not have to specify the alias of
			the function.

			The language of the function may optionally be defined using a field with the key
			"language", containing a string specifying the name of said language, and if this field
			is not present than a program may attempt to auto-detect the language based on the
			function code.

			If a function JSON object is the value of a field in another object, the function
			defined by it shall have the key of said field.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 3 - X-JSON ]#

X-JSON

	Philosophy

		-
			An X-JSON object is a JSON object that corresponds to an XML element.
		-

	Principles

		Structure

			Tag

				-
					An X-JSON object may have a field with the key "tag", the value of which must
					be a string specifying the tag name of the element.

					If no tag is specified, a certain tag may be assigned by default.
				-

			Attributes

				-
					An X-JSON object may have a field with the key "attributes", the value of which
					must be a field JSON object, where each field thereof specifies an attribute, the
					key being the attribute alias, and the value being the attribute content.
				-

			Children

				-
					An X-JSON object may have a field with the key "children", the value of which
					must be a list, where each value may either be a string, representing string
					content, or another X-JSON object, specifying a child element.
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 4 - DOM JSON ]#

DOM JSON

	Philosophy

		-
			A DOM JSON object is an extension of an X-JSON object that may be used to represent an
			HTML DOM element.

			If no tag is specified, the element will be assigned the tag "div" by default.
			
			A DOM JSON object may have a field with the key "style", the value of which must be a
			field JSON object, where each field thereof specifies a CSS style, where the key is the
			style alias and the value is the style content.
			
			A DOM JSON object may also have a field with the key "fields", the value of which must
			be a field JSON object, where each field thereof specifies a JavaScript variable, where
			the key is the variable alias and the value is the variable value.

			The "fields" object may specify some variables as functions using function JSON
			objects.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 5 - Style JSON ]#

Style JSON

	Philosophy

		-
			A style JSON object is a JSON object that corresponds to a CSS stylesheet.
			
			Each field within a style JSON object shall have a key specifying a CSS selector, and
			shall have a field JSON object as a value, where each field therein represents a CSS
			style, with the key specifying the style alias and the value specifying the style
			content.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 6 - HTTP JSON ]#

HTTP JSON

	Philosophy

		-
			An HTTP JSON object is a JSON object that corresponds to either an HTTP request or
			response.
		-

	Principles

		Definition Object

			-
				An HTTP JSON object must have a field containing a definition object.
				
				The alias of said field shall be "request" for an HTTP JSON object representing an
				HTTP request, and "response" for and HTTP JSON object representing an HTTP
				response.

				A definition object shall itself be a JSON field object, the contents of which
				shall differ depending on whether the HTTP JSON object containing it represents an
				HTTP request or response.

				For a request, a definition object shall have a field with the key "method", where
				the value shall be the method of the request, and shall havea field with the key
				"uri", where the value shall be the URI of the request, and may optionally have a
				field with the key "version", where the value shall be the version of the HTTP
				protocol.

				For a request, a definition object shall have a field with the key "version", where
				the value shall be the version of the HTTP protocol, and shall have a field with
				the key "status", where the value shall be the status of the response, and may also
				have a field with the key "reason", where the value is the reason phrase of the
				response.
			-

		Headers Object

			-
				An HTTP JSON object may optionally have a field with the key "headers" containing a
				JSON field object.

				For each field of said field object, the key shall specify the alias of an HTTP
				header, and the value shall specify the header's value.
			-

		Body Field

			-
				An HTTP JSON object may optionally have a field with the key "body" containing a
				string representing the body of the HTTP call.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 2 - JSON: 3 - JSON Schemas: 7 - File JSON ]#

File JSON

	Philosophy

		-
			An file JSON object is a JSON object that corresponds to a folder and its contents.
		-

	Principles

		Structure

			-
				Each field within a file JSON object corresponds to a resource within the folder
				that it represents, where the value of a field representing a folder shall be a
				file JSON object, and where the value of a field representing a file shall be a
				string containing the content of said file.
			-

		Virtual File Systems

			-
				A file JSON object may be used as an object representation of a file system and its
				contents in the set resource function of a file storage system interface in a
				virtual file system.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 1 - United JavaScript: 3 - Frameworks: 1 - Dynamic UI ]#

Dynamic UI Framework

	Philosophy

		-
			The dynamic UI framework is a set of conventions for managing the HTML DOM through
			JavaScript
		-

	Principles

		DOM JSON

			-
				The dynamic UI framework shall provide utilities for converting DOM JSON elements
				into DOM element objects, and vice versa.
			-

		Scripts

			-
				The dynamic UI framework shall provide the ability to attach scripts to DOM element
				objects in the form of functions which may be called by a looping script engine,
				and it shall also provide functions for managing said script engine.

				Each of said functions shall take the element object that it is intended to act on
				as an argument.

				Two of these functions shall be an on start and an on update function.

				The script engine may optionally be set to only look for scripts on elements that
				match specified CSS selectors.
			-

		Selector Scripts

			-
				The dynamic UI framework shall allow for the specification, via DOM JSON objects,
				of sets of properties that should be applied to elements matching certain CSS
				selectors upon their detection.
			-

		Dynamic UI Script Reference

			-
				A dynamic UI script reference is a JSON object specifying a set of selector
				scripts, where the alias of each field specifies a CSS selector and the value of
				each field is a DOM JSON object specifying the properties to apply to elements
				matching said selector upon their detection.
			-

		Loading

			-
				The dynamic UI framework shall provide functions that allow for the dynamic loading
				of external JavaScript scripts and CSS stylesheets.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C ]#

United C

	Philosophy

		-
			United C is a convention for C and C++ that allows them to work together as a hybrid
			language.
		-

	Principles

		Common C

			-
				Common C is a common convention for C and C++.
				
				The source code of a common C program muse be written in either C or C++, and said
				code must conform to the conventions of the latest standard of the respective
				language.

				Under the common C convention, C code may not use any language features of C that
				C++ does not possess.
			-

		United C

			Common C

				-
					United C follows the common C convention.
				-
			
			Main Function

				-
					Any operations placed outside a function will be placed into the main function
					upon the compilation of an executable. If a main function is not already
					declared, one will be inferred.

					The main function, whether manually created or automatically generated, shall
					be formatted to have a return type of int, shall return zero, and shall have a
					parameter argc of type int and a parameter argv of type char pointer array.

					If there is both a manually defined main function present as well as operation
					code placed outside the main function, the code within the manually defined
					main function shall execute before the code outside of it.
				-

			Declaration Order

				-
					Functions and global variables in United C may be declared in any order.
				-
			
			Type Detection

				-
					The token "var" may be in lieu of the data type of a varaible, in which case
					the type of said variable shall be predicted based on the value assigned to it.
				-

			Booleans

				-
					C code conforming to United C may use the literals true and false, which the
					preprocessor shall convert to 1 and 0 respectively, and may also use the data
					types bool and boolean, which the preprocessor shall convert to int.
				-

			Multiline Literals

				-
					United C allows multiline literals starting and ending with `.
					
					The ` character may be escaped using a backslash.
				-

			Addresses

				-
					United C allows @ to be used as the address token in addition to &.
				-

			Semicolons

				-
					United C code may omit semicolons where they are otherwise required.
				-

			Use

				-
					In place of the #include preprocessor, a sequence beginning with the token
					"use", referred to as a use directive, may be used in its place, where an
					indefinite number of paths to resources follow the use token, separated by
					commas.

					A use directive may terminate with either a new line or a semicolon.

					Paths to global resources may be written as they are, but paths to local
					resources must be encased in double quotes.

					If a path has no file extension, the system will check for any matching file
					with the extension "uc", "c", "h", or "cpp". If the extension cannot be
					verified, an extension of "uc" shall be inferred.
				-

			Online Dependencies

				-
					Include and use directives may reference dependencies stored online by their
					URLs, in which case the references must be encased in double quotes, as
					references to local resources would be.
				-

			Preprocessing

				-
					The main file and all local dependency files shall be preprocessed using the
					universal preprocessor upon compilation.
				-

		Usage

			Activation

				-
					A command or function used to generate United C should be named "United C" or
					"UC", adhering to the naming conventions of the language of its implementation,
					should take a string containing United C source code as an argument, and should
					return a string containing C or C++ code analogous to the input code. Such a
					command or function shall be called the United C transpilation function.

					The United C transpilation function may be called by a Universal Preprocessor
					directive, which should return the output of said command or function.
				-

			Compiler

				-
					United C shall have a custom compiler which shall take United C code, run the
					universal preprocessor on it, and then compile the resulting code as C if said
					code uses no C++ exclusive utilities, and as C++ otherwise.
				-

			Compilation

				-
					To compile an executable, the United C compiler shall only require the main
					file of said application.

					To compile a utility, the United C compiler shall require a flag indicating
					that it is compiling a utility as opposed to an executable as well as each file
					of the utility that is not included by any other file in said utility.
			
					If code written in United C uses any features that are in C++ but not in C, it
					shall be compiled as C++, and otherwise compiled as C.
				-

			Conventions

				-
					United C may be referred to as "UC".

					United C files should use the file extension ".uc".

					The United C Compiler may be abbreviated as "UCC".
				-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C: 1 - Kaeon FUSION Interface ]#

Kaeon FUSION United C Interface

	Philosophy

		-
			The Kaeon FUSION United C interface is a Kaeon FUSION interface that has the alias
			"United C", and which provides a Kaeon FUSION implementation of the United C
			transpilation function, implemented by way of causing the return value of the Kaeon
			FUSION process to be set to the transpiled C or C++ code generated by transpilating
			United C code passed to said process as the first argument.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C: 2 - Standard Library ]#

United C Standard Library

	Philosophy

		-
			The United C standard library shall define functions for C and C++ that provide certain
			functionality that normally requires different implementations for each language,
			allowing functions that provide said functionality to have the same interface, that is
			the same alias, parameters, and return type, in each language.

			This shall include but shall not necessarily be limited to console IO, file IO, dynamic
			lists, memory management, string processing, and multithreading.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C: 3 - Binary: 1 - Character Separated Binary ]#

Character Separated Binary

	Philosophy

		-
			A character separated binary document is a string that encodes binary data according to
			a protocol where the representations of each byte are separated by token strings.
		-

	Principles

		Protocol

			Binary

				-
					Each byte shall be represented as a number according to the protocol.

					The protocol for the representation of each number may be binary, octal,
					decimal, or hexadecimal.
				-

			Character

				-
					The protocol may specify one or more tokens which may separate the bytes.
				-

			Whitespace

				-
					Any whitespace aside from the separator tokens shall be trimmed.
				-

		Default Protocol

			-
				The default protocol uses binary to represent the bytes and any character other
				than one or zero as separator tokens.

				However, the best practice for the default protocol is to use single new lines to
				separate the bytes.
			-

		Abbreviation

			-
				Character separated binary may be abbreviated as CSB.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C: 3 - Binary: 2 - Dynamic Binary Headers ]#

Dynamic Binary Headers

	Philosophy

		-
			Dynamic binary headers allow metadata in binary files to be specified using a standard
			that can scale to varying lengths.
		-

	Principles

		Structure

			-
				Dynamic binary headers shall occur at the beginning of a binary file, and their
				content, which itself shall be in trinary, shall be specified using "11" to
				represent "2", "10" to represent "1", and "01" to represent "0", and shall end with
				"00".

				Following a header may be another header, the main content of the file, or the end
				or the file. No more headers may be placed into the file following the beginning of
				the main content.
			-

		Count Header

			-
				A count header, which if present must be the first header in the file, shall
				specify, as a trinary number, the number of headers present in the file, not
				counting itself.
			-

		Sequence Headers

			-
				If a count header is present, the headers that follow it may be sequence headers,
				each of which specify, as a trinary number, the length of a sequence of bits in the
				main content.

				The sequences defined by the sequence headers shall start at the beginning of the
				main content and shall be adjacent to one another, ordered according to the order
				of their corresponding headers.
				
				Any bits that follow the last sequence in the main content may be used for another
				purpose, if it is not junk data.
			-

		Sequence Objects

			-
				A binary file separated into sequences using sequences headers may itself be
				separated into sequences called sub-sequences using sequence headers.

				Sub-sequences may be used as references to the sibling sequences of their parent.

				If being used this way, each subsequence should have a header defining itself as
				either a reference or as raw data. The header for a reference should be "0100", and
				the header for raw data should be "1000".

				The content following a reference header should be a binary number specifying the
				index of the sibling sequence being referenced, starting at zero, and the content
				following a raw data header should be raw data in binary.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 2 - United C: 3 - Binary: 3 - Multistate Binary Sequence ]#

Multistate Binary Sequence

	Philosophy
	
		-
			A multistate binary sequence is a sequence of bit sequences, referred to as state
			sequences, each of which just long enough to encode a given number, defined as the
			order of the multistate binary sequence.

			Each state sequence shall specify in binary a number between zero and the order number,
			inclusive.
		-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 1 - United Suite: 3 - United Query Language ]#

United Query Language

	Philosophy

		-
			The United Query Language is a JSON based database query language.
		-

	Principles

		Requests

			-
				A United Query Language request takes the form of a JSON object.
				
				Said object must have a field with the alias "operation", and may optionally have
				fields with the aliases "location" and "type".

				The operation field specifies the database operation to perform. Its value may
				either be a JSON object specifying the operation in a format designed for the
				United Query Language, or a string specifying the operation in the format that the
				target database natively accepts.

				The location field, if present, shall contain a string specifying the URL of the 
				target database.

				The type field, if present, shall specify the type of database that the target
				database is.

				If the location and type fields are not present, their values shall be implicitly
				assumed.

				Executing the request shall return a JSON object or array, containing a field with
				the alias "data", which contains a JSON object specifying any data returned, and a
				field with the alias "error", which shall contain a null value if there was no
				error and shall contain a string specifying the error that occured if there was
				one.
			-

		Acronym

			-
				United Query Language can be referred to as UQL.
			-

#[ Kaeon United Specification: 2 - Suite: 2 - Conventions: 3 - Tools: 2 - United: 2 - Kaeon United ]#

Kaeon United

	Philosophy
	
		-
			Kaeon United is a an API that provides a unified interface to Kaeon FUSION and the
			United Suite.
		-
	
	Principles

		Format

			-
				Kaeon United shall be implemented as an HTJS file, which may be executed as a
				command line utility, imported into an HTML document using a script tag, imported
				as a CommonJS module, used as a Kaeon FUSION interface, or used as a shadow host
				for other applications.
			-

		Hosting

			-
				Kaeon United shall be hosted online so that users can use it via CDN regardless of
				the environment they are operating in.
			-

		Functionality

			Command Line

				-
					Running Kaeon United from the command line shall allow for the used of the
					United suite in the terminal.

					It shall take the following arguments:

					The first argument shall be the name of the utility within the united suite
					being used.
					
					Said utilities include "process", which runs Kaeon FUSION code, "parse", which
					converts ONE+ code to ONE, "preprocess", which runs the Universal Preprocessor,
					"js", which runs United JavaScript, "ucc", which runs the United C compiler,
					"assemble", which compiles CSB, and "disassemble", which disassembles CSB.

					To dynamically specify source text to the utility, the second argument must be
					"read", and the third argument must be said text itself.

					To load the source text to the utility from a file, the second argument must be
					"open", and the third argument must be the file path.

					To save the output of the utility to a file, there must be a fourth argument
					specifying the path of said file.

					Both the process and js utilities, if run without specified source text, will
					run as console REPLs.
				-

			HTML Script

				-
					Importing Kaeon United into an HTML document through a script tag shall allow
					the dynamic use of CommonJS on the page.
				-

			CommonJS Module

				-
					Importing Kaeon United as a CommonJS module shall return an object containing
					all of the CommonJS modules relevant to the United suite.
				-

			Kaeon FUSION Interface

				-
					Using Kaeon United as a Kaeon FUSION interface shall cause the Kaeon FUSION
					interpreter to use all of the most generally relevant Kaeon FUSION interfaces.
				-

			Shadow Host

				-
					If Kaeon United is used as a shadow host, it may have the URL arguments
					"UnitedJS", "UnitedJSRaw", "UnitedOP", "UnitedOPRaw", "HTML", and "HTMLRaw".

					UnitedJS, if present, shall specify the path to a United JavaScript file which
					shall be executed.

					UnitedJSRaw, if present, shall specify United JavaScript code which shall be
					executed.

					UnitedOP, if present, shall specify the path to a Kaeon FUSION file which shall
					be executed.

					UnitedOPRaw, if present, shall specify the path to a Kaeon FUSION file which shall
					be executed.

					HTML, if present, shall specify the path to an HTML file which shall be
					rendered.

					If both more than one of the aforementioned arguments are present, the
					JavaScript, if given, shall execute first, the Kaeon FUSION, if given, shall
					execute next, and the HTML, if given, shall be rendered last.

					If none of the aforementioned arguments are present, a page displaying a user
					guide for Kaeon United shall be rendered.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard ]#

Kaeon FUSION Standard Interface
	
	Philosophy
		
		-
			The Kaeon FUSION standard interface provides commands that allow users to write Turing
			complete scripts in Kaeon FUSION.
		-
	
	Principles
		
		Alias
			
			-
				The Kaeon FUSION standard interface may be referenced using the alias "Standard".
			-
		
		Effects

			Properties
			
				Use
				
					-
						When the standard interface is in effect, Kaeon FUSION's use command will
						have priority over all other commands, and will integrate interfaces
						according to the string forms of the values returned by its children
						instead of the content of said children.
					-
				
				State
					
					-
						The Kaeon FUSION Standard Interface establishes a state that stores data
						between commands.
						
						Every item stored in the state will have a string alias to identify it. The
						data stored within the item may be of any data type. Certain items may be
						declared as global.
						
						After a command is processed, items in the state generated by its children
						that are not global are deleted. If FUSION jumps, items in the state not
						generated by the parent, grandparents, and the preceding siblings of the
						parents and grandparents of the element it landed on that are not global
						will be deleted.

						At any time the state may be serialized to a dynamic list.
					-
				
				Exceptions
					
					-
						If an exception is thrown by a command while the standard interface is
						active, all subsequent commands will fail to activate until the exception
						is caught.
					-
			
			Host Environment
				
				Arguments
				
					-
						The host environment of a script using the standard interface may pass an
						indefinite number of arguments to the script.
					-
				
				Console
					
					-
						The host environment of a script using the standard interface may provide
						an alternate console for the script to output to. By default, the console
						is standard out.
					-
				
				Build Workspace
					
					-
						In addition to the workspaces present by default in Kaeon FUSION, the
						standard interface also allows the host environment to specify a single
						build workspace, which in addition to becoming part of the workspace, will
						also serve as the default directory for file output.
						
						By default, the build workspace is the local directory.
					-
		
		Conventions
		
			Implicit Casting
				
				-
					Values stored within the state have types, but, if possible, will be implicitly
					cast when passed as arguments to a command requiring parameters of a different
					type.
				-
			
			Case Sensitivity
				
				-
					All of the commands provided by the standard interface, with the exception of
					literals, do not take letter case into account.
				-
			
			Lists
				
				Strings in List Operations
					
					-
						Strings will be interpreted as lists where each character is an element
						when used as arguments in list operations.
					-

				List Indexes
					
					-
						Commands in the standard interface that pertain to lists use indexes that
						start at one. If a command attempts to access or modify an index of a list
						that does not exist, the list will be resized to accommodate the index.
					-
				
				Dynamic Lists

					-
						Lists used by the standard interface will be dynamic lists, which shall
						also serve as de facto objects.
					-
		
		Formats

			State Serialization Format

				-
					When the state is serialized as a list, said list is encoded in the state
					serialization format.

					Each item in the state is encoded as a list called an item list which has two
					elements, the first being the alias and the second being the value.

					Each scope in the state will be stored as a scope list, which shall contain an
					indefinite amount of item lists.

					The state itself shall be encoded as a list called the state list, with each
					scope of said state being represented as a scope list, where the first scope
					list shall represent the global scope, and each subsequent list shall represent
					a local scope, arranged according to their order on the current scope stack.
				-

		DOM

			-
				The host environment for the Kaeon FUSION standard interface may provide an HTML
				DOM with which a Kaeon FUSION script may interface.

				If elements are injected into the DOM in HTTP JSON format or any analogue to it,
				any objects in function JSON format or any analogue to it shall be converted into
				functions.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 1 - Undefined: 1 - Literals ]#

Literals
	
	Philosophy
		
		-
			A command with content that does not match the name of a defined command or any alias
			in the state and has no children will return its content as a string.
			
			If its content begins and ends with a double quote, the double quotes will be cropped
			from the returned content.
			
			Any sequence within the returned string consisting of a backslash followed by another
			character will be interpreted based on what the second character in the sequence is,
			with an 'n' denoting a new line, a 't' denoting a tab, and any other character denoting
			itself.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 1 - Undefined: 2 - Variables ]#

Variables
	
	Philosophy
		
		-
			A command with content that does not match the name of a defined command or any alias
			in the state and has one child will create an item in the state with the item's value
			being the object returned by the command's child and them item's alias being the
			command's content.
			
			A command with content that matches an alias of an item that is not a function
			definition in the state will, if it has children, assign the object returned by its
			first child to the item that corresponds to the alias, and regardless of whether or not
			it has children, will return the value of the item that corresponds to the alias.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 1 - Define ]#

Define
	
	Philosophy
	
		-
			The define command contains the content "Define" and may have an indefinite number of
			children. It does not trickle down.
			
			It will return an element in ONE list form equal to itself with no content with all the
			elements in its scope.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 10 - Form ]#

Form

	Philosophy
	
		-
			The form command contains the content "Form". It must have a single child that may
			return any object.
			
			It will return the string "Boolean" if the string form of the returned object matches a
			boolean value, the string "Number" if the string form of the returned object matches a
			numerical value, and the string "String" if the string form of the returned object does
			not match a boolean or a numerical value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 11 - Is Command ]#

Is Command

	Philosophy
	
		-
			The is command command contains the content "Is Command". It must have a single child
			that returns a string.
			
			It will return true if the returned string would be interpreted as a command other than
			a literal, variable, or function call if it were the content of a Kaeon FUSION command.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 12 - Is Variable ]#

Is Variable

	Philosophy
	
		-
			The is variable command contains that content "Is Variable". It has one child that
			returns a string and may optionally have a second child that returns a boolean.
			
			It will return true if there is a variable alias in the state that matches the returned
			string. If the second child is present and returned false, then the command will only
			check the local scope. If the second child is present and returned true, then the
			command will only check the global scope.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 13 - Destroy ]#

Destroy

	Philosophy
	
		-
			The destroy command contains that content "Destroy". It has one child that returns a
			string and may optionally have a second child that returns a boolean.
			
			It will delete any variable alias in the state that matches the returned string. If the
			second child is and returned false, then the command will only delete values in the
			local scope. If the second child is present and returned true, then the command will
			only delete values in the global scope.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 14 - Variables ]#

Variables

	Philosophy
	
		-
			The variables command contains the content "Variables". It may optionally have a child
			that returns a boolean value.
			
			It returns a list of all variable aliases stored in the state. If it has a child and
			the child returns false, then the list will only contain aliases from the local scope.
			If it has a child and the child returns true, then the list will only contain aliases
			from the global scope.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 15 - Get Code ]#

Get Code

	Philosophy
	
		-
			The get code command contains the content "Get Code".
			
			It returns the root element of the script it was called from in ONE list form.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 16 - Get Code Index ]#

Get Code Index

	Philosophy
	
		-
			The get code index command contains the content "Get Code Index".
			
			It creates a list, and then starting from the command that called it, adds the index of
			said command to the beginning of said list, and trickles up to said command's parent
			until it reaches the root. It then returns the generated list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 17 - With ]#

With

	Philosophy
	
		-
			The with command contains the content "With". It has two children, the first of which
			returns a string or a list and the second of which returns a list.
			
			It will execute a command where, if the first child returned a string then said string
			shall be the content of the command, and if the first child returned a list then the
			list is the command in ONE list form, and the elements of the list returned by the
			second child are the values passed to the command by its children. It will then return
			the value returned by the command.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 18 - Disable ]#

Disable

	Philosophy
	
		-
			The disable command contains the content "Disable". It may have an indefinite number of
			children, where each of the string forms of the values they return are used to activate
			a given command.
			
			It disables the commands activated by the string forms of the returned values.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 19 - Enable ]#

Enable

	Philosophy
	
		-
			The enable command contains the content "Enable". It may have an indefinite number of
			children, where each of the string forms of the values they return are used to activate
			a given command.
			
			It re-enables the commands activated by the string forms of the returned values that
			have been disabled by the disable command.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 2 - Global ]#

Global
	
	Philosophy
	
		-
			The global command contains the content "Global" and may have an indefinite number of
			children.
			
			The content of each child will become a global alias in the state.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 20 - Lock Down ]#

Lock Down

	Philosophy
	
		-
			The lock down command contains the content "Lock Down". It may have an indefinite
			number of children, where each of the string forms of the values they return are used
			to activate a given command.
			
			It permanently disables the commands activated by the string forms of the returned
			values.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 21 - Reflect ]#

Reflect

	Philosophy
	
		-
			The reflect command contains the content "Reflect". It must have eight children, each
			of which either return an element in ONE list form or a null value.
			
			Every returned value corresponds to a function in a FUSION unit as defined by the
			FUSION interpreter architecture, with the first corresponding to the deny function, the
			second corresponding to the verify function, the third corresponding to the trickle
			down function, the fourth corresponding to the process function, the fifth
			corresponding to the terminate function, the sixth corresponding to the is added
			function, the seventh corresponding to the jump function, and the eighth corresponding
			to the handle error function.
			
			A FUSION unit will be generated by the command where if an element in ONE list form is
			returned, the FUSION unit function corresponding to the value that returned the element
			will be overridden by the said element as Kaeon FUSION code.
			
			All of said functions will take a ONE element in extended ONE list form as their first
			argument, with the process, terminate, is added, jump, and handle error functions
			taking a list of objects representing the values returned by said ONE element's
			children as their second argument, and with the handle error function taking a string
			containing an error message as its third argument.
			
			If the jump function returns an element, said element will be in extended ONE list
			form.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 22 - Interpreter ]#

Interpreter

	Philosophy
	
		-
			The interpreter command contains the content "Interpreter".
			
			It returns a reference to the interpreter that FUSION is running on if it is an object
			within the host environment, and returns null otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 23 - Listen ]#

Listen

	Philosophy
	
		-
			The listen command contains the content "Listen". It may have an indefinite number of
			children, each of which return a list.
			
			If the interpreter receives packets from its host environment, their contents will be
			appended to any lists that at any point were passed to a listen command through said
			command's children.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 24 - Be ]#

Be
	
	Philosophy
		
		-
			The be command is a command with the content "Be". It has one child that returns a list
			containing a serialized state in state serialization format.

			It replaces the current state with the state serialized in the returned list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 25 - Call ]#

Call
	
	Philosophy
		
		-
			The call command contains the content "Call".
			
			It sends the host environment of Kaeon FUSION a packet containing all of the objects
			returned by its children. The operation that is then performed and the value that the
			command returns are dependent on the implementation of the host environment and on the
			interfaces currently in use.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 26 - Direct ]#

Direct

	Philosophy

		-
			The direct command contains the content "Direct". It may have either one or two
			children, each of which return a string, where if both are present, the first shall
			specify the name of a programming language or environment and the second shall contain
			code for said language or environment, and if only one is present, it shall contain
			code for a given programming language or environment.

			The direct command shall execute the returned code, where if a language or environment
			was specified, it shall be executed in said language or environment, and if a language
			or environment was not specified, the language or environment shall be detected
			automatically, and the result of the executed code shall be returned by the direct
			command.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 27 - Optimize ]#

Optimize

	Philosophy

		-
			The optimize command contains the content "Optimize". It has one child which returns a
			ONE element in ONE list form, and may optionally have a second child that returns a
			list.

			The optimize command shall, while using the contents of the list returned by the second
			child if it is present, analyze the element returned by the first child as Kaeon FUSION
			code and return an optimized version of said Kaeon FUSION code as a ONE element in ONE
			list form.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 28 - Inject ]#

Inject

	Philosophy
	
		-
			The inject command contains the content "Inject". It has one child, which shall return
			a ONE element, either as a ONE+ string or in ONE list form.
			
			It will replace itself within the script it belongs to with the element returned by its
			child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 3 - Do ]#

Do

	Philosophy

		-
			The do command contains the content "Do". It shall have either one or two children, the
			first of which shall return an element in ONE list form, and the second of which, if
			present, shall return a list, the contents of which may be anything.

			It shall virtually execute the element defined by the first list with its own return
			value and a new state, sharing the values stored in the global state, with the second
			list, if present, defining arguments for the element to execute with. After the
			execution, the do command shall return the value of the new return value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 4 - Arguments ]#

Arguments
	
	Philosophy
		
		-
			The arguments command contains the content "Arguments"
			
			If called within a function or script to which arguments were passed, it returns said
			arguments in the form of a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 5 - This ]#

This
	
	Philosophy
		
		-
			The this command contains the content "This".
			
			It returns a list containing the serialized contents of the state.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 6 - New ]#

New
	
	Philosophy
		
		-
			The new command contains the content "New".
			
			It has one child that executes a Kaeon FUSION script virtually. It returns the contents
			of the state of the virtually executed script serialized as a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 7 - Null ]#

Null
	
	Philosophy
		
		-
			The null command contains the content "Null".
			
			It returns a null value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 8 - Literal ]#

Literal
	
	Philosophy
		
		-
			The literal command contains the content "Literal". It must have a single child.
			
			It returns the content of its child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 1 - Data: 9 - Type ]#

Type
	
	Philosophy
		
		-
			The type command contains the content "Type". It must have a single child.
			
			It returns the type of its child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 1 - Connect ]#

Connect

	Philosophy

		-
			The connect command is a command with the content "Connect". It has between three and
			five children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, the second and third of which may return any value, the fourth of
			which, if present, shall return a list of Kaeon FUSION scripts in ONE list form, and
			the fifth of which, if present, shall return a boolean.

			It forms a connection in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fifth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child, and if the fourth child is present the scripts it
			returns shall serve as atlas policies for the new connections, taking a given traversal
			path in the form of a list as an argument. Any pre-existing connections between the
			connected values shall be overridden.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 2 - Disconnect ]#

Disconnect

	Philosophy

		-
			The disconnect command is a command with the content "Disconnect". It has either three
			or four children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, the second and third of which may return any value, and the fourth
			of which, if present, shall return a boolean.

			It removes connections in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fourth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 3 - Is Connected ]#

Is Connected

	Philosophy

		-
			The is connected command is a command with the content "Is Connected". It has between
			three and five children, the first of which shall return a list containing the state of
			a Philosopher's Atlas, the second and third of which may return any value, the fourth
			of which, if present, shall return a list of Kaeon FUSION scripts in ONE list form, and
			the fifth of which, if present, shall return a boolean.

			If a connection exists in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fifth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child, and if the fourth child is present the scripts it
			returns serve as atlas policies for the specified connections, then it shall return
			true, and return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 4 - Get Connections ]#

Get Connections

	Philosophy

		-
			The get connections command is a command with the content "Get Connections". It has two
			children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, and the second of which may return any value.

			It returns all values that the value returned by the second child is connected to in
			the returned Philosopher's Atlas.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 5 - Get Policies ]#

Get Policies

	Philosophy

		-
			The get policies command is a command with the content "Get Policies". It has three
			children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, and the second and third of which may return any value.

			It returns all Kaeon FUSION scripts in ONE list form that serve as connection policies
			for the connection from the value returned by the second child to the value returned by
			the third child within the returned Philosopher's Atlas.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 6 - Traverse ]#

Traverse

	Philosophy

		-
			The traverse command is a command with the content "Traverse". It has two children, the
			first of which shall return a list containing the state of a Philosopher's Atlas, and
			the second of which may return any value.

			It performs a traversal of the returned Philosopher's Atlas starting at the value
			returned by the second child, and returns a list of all values traversed across during
			said traversal.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 7 - Train ]#

Train

	Philosophy

		-
			The train command is a command with the content "Train". It has four children, the
			first of which shall return a list containing the corpus of a SOUL, the second and
			third of which may return any value, and the fourth of which shall return a number
			between zero and one, inclusive.

			It trains the returned corpus by correlating the value returned by the second child as
			input to the value returned by the third child as output. The correlation shall be
			assumed to be one to one by default if the fourth child is not present, otherwise the
			correlation shall be specified by the value returned by the fourth child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 8 - Generate ]#

Generate

	Philosophy

		-
			The generate command is a command with the content "Generate". It may have either two
			or three children, the first of which shall return a list containing the corpus of a
			SOUL, the second of which may return any value, the third of which shall return a
			number between zero and one, inclusive.

			It shall generate and return a value that correlates as output to the value returned by
			the second child as input with a one to one correlation if the third child is not
			present and with the correlation specified by the third child if it is present
			according to the returned corpus.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 10 - Philosopher's Stone: 9 - Correlate ]#

Correlate

	Philosophy

		-
			The correlate command is a command with the content "Correlate". It has three children,
			the first of which shall return a list containing the corpus of a SOUL, and the second
			and third of which may return any value.

			It shall determine and return a value between zero and one, inclusive, corresponding to
			the correlation between the value returned by the second child as input and the value
			returned by the third child as output according to the returned corpus.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 1 - Get UI ]#

Get UI

	Philosophy

		-
			The get UI command is a command with the content "Get UI". It may have an indefinite
			number of children, each of which return strings containing CSS selectors.

			It shall return all elements in the host DOM, if present, that match any of the
			specified selectors, each as a dynamic list corresponding to a DOM JSON representation
			of the corresponding element.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 2 - Set UI ]#

Set UI

	Philosophy

		-
			The set UI command is a command with the content "Set UI". Its first child shall return
			a dynamic list representing a DOM element in DOM JSON format, and it may have an
			indefinite number of additional children, each of which shall return strings specifying
			CSS selectors.

			It shall find each of the elements present in the host DOM, if present, that match the
			specified CSS selectors and modify their properties to match the specified properties
			of the returned element.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 3 - Extend UI ]#

Extend UI

	Philosophy

		-
			The extend UI command is a command with the content "Extend UI". Its first child shall
			return a string containing a CSS selector, and it may have an indefinite number of
			other children which return dynamic lists representing DOM elements in DOM JSON format.

			It shall append all of the specified elements to the first existing element matching
			the specified selector in the host DOM, if present.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 4 - Delete UI ]#

Delete UI

	Philosophy

		-
			The delete UI command is a command with the content "Delete UI". It may have an
			indefinite number of children, each of which return strings containing CSS selectors.

			It shall delete all of the elements matching the returned selectors within the host
			DOM, if present.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 5 - Specify UI ]#

Specify UI

	Philosophy

		-
			The specify UI command is a command with the content "Specify UI". It shall have an
			indefinite number of children, each of which return a list containing a string
			specifying a CSS selector as its first element and either a dynamic list representing a
			DOM element in DOM JSON format or a null value as its second element.

			Every returned list shall establish a rule in the host DOM, if present, that any
			element matching the specified selector in the host DOM shall have the specified
			properties of the specified element, if said element is not null.

			Subsequent uses of this command may override rules established by previous uses of it
			if the same selector is used, and said rules may be erased if the specified elements
			are null.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 11 - UI: 6 - Load UI ]#

Load UI

	Philosophy

		-
			The load UI command is a command with the content "load UI". It shall have an
			indefinite number of children, each of which shall return a string specifying a path
			to either a JavaScript script or to a CSS stylesheet.

			It shall load all of the specified resources into the host DOM, if present.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 1 - Return ]#

Return
	
	Philosophy
		
		-
			The return command contains the content "Return", and may have an indefinite number of
			children.
			
			It prevents any subsequent commands in the script or function from which it is called
			from executing. If it has no children, it will return a null value. If it has one
			child, it will return the value returned by its child. If it has more than one child,
			it will return all of the values returned by its children in a list. It will set
			Kaeon FUSION's return value whatever it returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 10 - Split ]#

Split
	
	Philosophy
		
		-
			The split command contains the content "Split".
			
			It does not trickle down and executes all of its children in a new Kaeon FUSION script
			on a new thread using a deep copy of the state of the script or function from which it
			was called.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 11 - Run ]#

Run
	
	Philosophy
		
		-
			The run command contains the content "Run". It may have an indefinite number of
			children, each of which return a string.
			
			It runs each returned string as a command line call, and returns a list of lists, one
			for each returned string, arranged in the order said strings were returned, where each
			sublist contains three lists. Any output from a spawned process to standard output will
			be appended to the first list in the list that corresponds to the string that spawned
			said process. The spawned process that was spwaned by the string that corresponds to a
			given list may access the string form of any object in said list's second list through
			standard in. Any output from a spawned process to standard error will be appended to
			the third list in the list that corresponds to the string that spawned said process.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 12 - Automatic Catch ]#

Automatic Catch

	Philosophy
	
		-
			The automatic catch command contains the content "Automatic Catch". It must have a
			single child that returns a boolean.
			
			If the returned boolean is true, exceptions thrown following the execution of the
			command will be automatically caught. If the returned boolean is false, exceptions
			thrown following the execution of the command will not be automatically caught.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 13 - Throw ]#

Throw
	
	Philosophy
		
		-
			The throw command contains the content "Throw". It does not trickle down.
			
			It will throw an exception, preventing any subsequent commands from executing until the
			exception is caught.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 14 - Exit ]#

Exit
	
	Philosophy
		
		-
			The exit command contains the string "Exit".
			
			It completely stops the execution of Kaeon FUSION.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 15 - Exception ]#

Exception
	
	Philosophy
		
		-
			The exception command contains the string "Exception".
			
			It returns the reason for the most recently thrown exception as a string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 16 - Retrieve ]#

Retrieve

	Philosophy
	
		-
			The retrieve command contains the content "Retrieve". It may have an indefinite number
			of children.
			
			It will generate a value that is either the value returned by its first child if
			exactly one value was returned to it, or a list of all of the values returned to it
			otherwise. If its parent command has content and would otherwise return a null value,
			it will instead return the generated value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 17 - Shift ]#

Shift

	Philosophy
	
		-
			The shift command contains the content "Shift". Its first child must return a list
			representing a ONE element in ONE list form. It may optionally have a second child that
			returns a list of integer numbers.
			
			The shift command will generate a ONE element from the first list. If a second list was
			not returned, FUSION will jump to the root of the generated element. If a second list
			was returned, the shift command will trickle down the generated element at the indexes
			specified by the integers in the second list, and will jump to the element it lands on.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 18 - Flip ]#

Flip

	Philosophy
	
		-
			The flip command contains the content "Flip". Its first child that returns a boolean,
			and it may optionally have a second child that also returns a boolean.
			
			If the returned boolean is true, the command will reverse the order of all of the
			elements in the scope of the root of the elements that FUSION is acting on, causing the
			program to flow in reverse. If the second child is present and returns true, the
			command will only affect the elements within the scope of the command's parent element.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 19 - Block ]#

Block
	
	Philosophy
		
		-
			The block command contains the content "Block". It does not trickle down.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 2 - Catch ]#

Catch
	
	Philosophy
		
		-
			The catch command contains the content "Catch".
			
			Unless an exception was thrown by a previous command, it will not trickle down. If it
			does trickle down, it will catch any exception thrown by a previous command as it does
			so.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 20 - Ternary ]#

Ternary

	Philosophy
	
		-
			The ternary command contains the content "Ternary". It may have either two or three
			children, the first of which returns a boolean and the second, and third of which if
			present, may return any value.
			
			If the boolean value returned by its first child is true, it will return the value
			returned by its second child, and otherwise will return null if the third child is not
			present and will return the value returned by its third child if said child is present.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 21 - Isolate ]#

Isolate

	Philosophy
	
		-
			The isolate command contains the content "Isolate".
			
			It will prevent any command within its scope from modifying the state of the script it
			was called from.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 22 - Vanish ]#

Vanish

	Philosophy
	
		-
			The vanish command contains the content "Vanish".
			
			After all of the commands within its scope have been executed, it will be removed from
			the script it belongs to.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 23 - Reverse Catch ]#

Reverse Catch

	Philosophy
	
		-
			The reverse catch command contains the content "Reverse Catch".
			
			Unless an exception was thrown by a previous command, it will not trickle down. If it
			does trickle down, commands within its scope will be executed despite the exception
			that triggered it, but said exception will not be caught by the reverse catch command.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 24 - For ]#

For

	Philosophy
	
		-
			The for command contains the content "For" and has two children, the first of which
			returns an integer number or a list, and the second of which returns a ONE element in
			ONE list form.
			
			If the value returned by the first child is a number, it shall execute the returned ONE
			element as Kaeon FUSION code for the number of iterations specified by the returned
			number, where upon each iteration it shall pass to said code the index of the current
			iteration, starting at one. If the value returned by the first child is a list, it will
			execute the returned ONE element as Kaeon FUSION code for each element in the returned,
			where upon each iteration it shall pass to said code the element of the list
			corresponding to the current iteration. 
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 25 - If ]#

If

	Philosophy
	
		-
			The if command contains the content "If" and has two children, the first of which
			returns a boolean, and the second of which returns a ONE element in ONE list form.
			
			If the value returned by the first child is true, it shall execute the returned ONE
			element as Kaeon FUSION code.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 26 - While ]#

While

	Philosophy
	
		-
			The while command contains the content "While" and has two children, each of which
			return a ONE element in ONE list form.
			
			It will execute the element returned by the first child as Kaeon FUSION code, and if it
			returns a value of true, it shall execute the element returned by the second child as
			Kaeon FUSION code and then repeat then process.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 3 - Catch Enabled ]#

Catch Enabled

	Philosophy
	
		-
			The catch enabled contains the content "Catch Enabled".
			
			It returns true if automatic exception catching enabled using the automatic catch
			command is currently in effect, and returns false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 4 - Scope ]#

Scope

	Philosophy
	
		-
			The scope command is a command with the content "Scope".
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 5 - Execute ]#

Execute
	
	Philosophy
		
		-
			The execute command contains the content "Execute", and may have an indefinite number
			of children, each of which return a list representing a ONE element in ONE list form.
			
			It will interpret each returned list as a ONE element and execute said elements in
			order as Kaeon FUSION code within the namespace of the script or function it was called
			from.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 6 - Break ]#

Break
	
	Philosophy
		
		-
			The break command contains the content "Break". It may any combination of a child that
			returns a boolean and a child that returns a positive integer number.
			
			If it has a child that returns a boolean value of false, it will not execute.
			Otherwise, it will prevent its siblings from executing, and if it has a child that
			returns a number, will bubble up its parent connections for the as many times as
			specified by the returned number and prevent any siblings of the command it lands on as
			well as any commands within its scope from executing.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 7 - Else ]#

Else
	
	Philosophy
		
		-
			The else command contains the content "Else".
			
			It will only trickle down if the most recently called break command nested beneath one
			of its preceding siblings had a child that returned false.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 8 - Loop ]#

Loop
	
	Philosophy
		
		-
			The loop command contains the content "Loop". It may any combination of a child that
			returns a boolean and a child that returns a positive integer number.
			
			If it has a child that returns a boolean value of false, it will not execute.
			Otherwise, if it does not have a child that returns a number, it will jump to the first
			child of its parent, and if it does have a child that returns a number, it will bubble
			up its parent connections for as many times as specified by the returned number and
			will jump to the first child of the parent of the element that it lands on.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 2 - Flow Control: 9 - Wait ]#

Wait
	
	Philosophy
		
		-
			The wait command contains the content "Wait", and has one child that returns a number.
			
			It will pause the execution of the script or function from which it was called for the
			number of seconds specified by the number returned by its child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 1 - Log ]#

Log

	Philosophy
	
		-
			The log command is a command with the content "Log".
			
			It prints all of the objects returned to it to the console.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 2 - Log Line ]#

Log Line
	
	Philosophy
	
		-
			The log line command is a command with the content "Log Line".
			
			It prints all of the objects returned to it followed by a new line to the console.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 3 - Log Error ]#

Log Error

	Philosophy
	
		-
			The log error command is a command with the content "Log Error".
			
			It prints all of the objects returned to it to the console in the form of an error.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 4 - Log Line Error ]#

Log Line Error
	
	Philosophy
	
		-
			The log line error command is a command with the content "Log Line Error".
			
			It prints all of the objects returned to it followed by a new line to the console in
			the form of an error.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 5 - Log Clear ]#

Log Clear

	Philosophy
	
		-
			The log clear command is a command with the content "Log Clear".
			
			It clears the console, and then prints all of the objects returned to it to the
			console.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 6 - Log Line Clear ]#

Log Line Clear
	
	Philosophy
	
		-
			The log line clear command is a command with the content "Log Line Clear".
			
			It clears the console, and then prints all of the objects returned to it followed by a
			new line to the console.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 7 - Input ]#

Input
	
	Philosophy
		
		-
			The input command contains the content "Input". It may have an indefinite number of
			children.
			
			If it has no children, it will return the next value returned by standard in. If it
			does have children, it will print the values returned by each of its children to the
			console, prompt the user for input and then return the string that was entered by the
			user.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 3 - Console: 8 - Get Log ]#

Get Log
	
	Philosophy
	
		-
			The get log command is a command with the content "Get Log".
			
			It returns the text in the console as a string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 1 - Operating System ]#

Operating System

	Philosophy
	
		-
			The operating system command contains the content "Operating System".
			
			It returns the name of the operating system of the device Kaeon FUSION is running on as
			a string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 10 - Addresses ]#

Addresses

	Philosophy
	
		-
			The addresses command contains the content "Addresses". It may have one child that
			returns a string in the form of a domain name.
			
			If it has no children, it will return the IP addresses of the device that Kaeon FUSION
			is running on as a list. If it does have a child, it will return the IP addresses of
			the specified domain name as a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 2 - Time ]#

Time
	
	Philosophy
		
		-
			The time command contains the content "Time".
			
			It returns the time on the computer's clock in seconds.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 3 - Year ]#

Year

	Philosophy
	
		-
			The year command contains the content "Year".
			
			It returns the current year according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 4 - Month ]#

Month

	Philosophy
	
		-
			The month command contains the content "Month".
			
			It returns the current month according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 5 - Day ]#

Day

	Philosophy
	
		-
			The day command contains the content "Day".
			
			It returns the current day according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 6 - Hour ]#

Hour

	Philosophy
	
		-
			The hour command contains the content "Hour".
			
			It returns the current hour according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 7 - Minute ]#

Minute

	Philosophy
	
		-
			The minute command contains the content "Minute".
			
			It returns the current minute according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 8 - Second ]#

Second

	Philosophy
	
		-
			The second command contains the content "Second".
			
			It returns the current second according to the computer's clock as a number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 4 - System: 9 - Weekday ]#

Weekday

	Philosophy
	
		-
			The weekday command contains the content "Weekday".
			
			It returns the current day of the week according to the computer's clock as a string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 1 - Open ]#

Open
	
	Philosophy
		
		-
			The open command contains the content "Open". It has one child that returns a string
			value.
			
			It will return the content of the file located at the path specified by the returned
			string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 10 - Is Directory ]#

Is Directory

	Philosophy
	
		-
			The is directory command contains the content "Is Directory". Is has one child that
			returns a string in the form of a file path.
			
			It will return true if the returned file path leads to a directory and will return
			false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 11 - File Exists ]#

File Exists

	Philosophy
	
		-
			The file exists command contains the content "File Exists". Is has one child that
			returns a string in the form of a file path.
			
			It will return true if a file or directory exists at the returned file path and will
			return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 12 - Separator ]#

Separator

	Philosophy
	
		-
			The separator command contains the content "Separator".
			
			It returns the file path separator string of the device that Kaeon FUSION is running
			on.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 13 - Is Hidden ]#

Is Hidden

	Philosophy
	
		-
			The is hidden command contains the content "Is Hidden". It has one child that returns a
			string in the form of a file or directory path.
			
			It returns true if the file or directory located at the returned path is hidden, and
			returns false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 14 - File Size ]#

File Size

	Philosophy
	
		-
			The file size command contains the content "File Size". Its first child returns a
			string containing a file or directory path, and it may optionally have a second child
			that returns a boolean.
			
			If it has a second child and said child returns true, it will return the space the file
			or directory at the returned path takes up on disk. Otherwise, it will return the size
			of the file or directory.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 15 - Rename ]#

Rename

	Philosophy
	
		-
			The rename command contains the content "Rename". It has two children, both of which
			return strings that contain file or directory paths.
			
			It renames the path of the file or directory located at the path returned by the first
			child to the path returned by the second child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 16 - Path Separator ]#

Path Separator

	Philosophy
	
		-
			The path separator command contains the content "Path Separator".
			
			It returns the path separator string of the device that Kaeon FUSION is running on.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 17 - Source Workspaces ]#

Source Workspaces

	Philosophy
	
		-
			The source workspaces command contains the content "Source Workspaces".
			
			It returns a list containing all of the paths to the source workspaces currently in use
			by Kaeon FUSION.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 18 - Build Workspace ]#

Build Workspace

	Philosophy
	
		-
			The build workspace command contains the content "Build Workspace".
			
			It returns the path to the build workspace currently in use by the standard interface.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 19 - Read Bytes ]#

Read Bytes

	Philosophy

		-
			The read bytes command is a command with the content "Read Bytes". It may have between
			one and three children, the first of which shall return a string containing a file
			path, and the second and third of which, if present, shall return integer numbers
			greater than or equal to one.

			It shall read the raw bytes from the file specified by the returned path and return
			them as an assembly dialect document where the mode is binary. If the second number is
			present, it shall start reading at the index specified by said number, and if the third
			number is present, it shall stop reading at the index specified by said number, where
			indicies start at one.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 2 - Save ]#

Save
		
	Philosophy
		
		-
			The save command contains the content "Save". It has two children, each of which return
			a string.
			
			It will save a file containing the first string at the path specified by the second
			string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 20 - Write Bytes ]#

Write Bytes

	Philosophy

		-
			The write bytes command is a command with the content "Write Bytes". It shall either
			two or three children, the first of which returns an assembly dialect document, the
			second of which returns a string containing a file path, and the third of which, if
			present, returns an integer number greater than or equal to one.

			It writes the bytes specified by the returned assembly dialect document to the file
			specified by the returned path. If the returned number is present, it shall start
			writing the bytes to the file at the index specified by said number where indicies
			start at one.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 21 - Send ]#

Send

	Philosophy

		-
			The send command is a command with the content "send". It shall have one child which
			shall return either a string containing a raw HTTP request or a dynamic list
			corresponding to an HTTP request in HTTP JSON format, and may also have an additional
			child which returns a list.

			The returned response shall be converted into a dynamic list corresponding to the same
			response in HTTP JSON format. If the second child is not present, it shall execute the
			request synchronously and return the returned list, and if the list is present, it
			shall execute the request asynchronously and execute the returned list as a Kaeon
			FUSION function, passing the returned list to it as an argument.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 22 - Host ]#

Host

	Philosophy

		-
			The host command is a command with the content "Host". It shall between two and four
			children, the first of which returns a list of lists, the second of which returns a
			number specifying a port, the third of which, if present, shall return either a null
			value or a list containing two strings, and the fourth of which, if present, shall
			return either a boolean or a string specifying a domain name.

			The host command shall establish a server with routes defined by each of the
			aforementioned lists running at the specified port. If the third child, if present,
			returned a list, the server shall run in HTTPS mode, where the first string in said
			list shall specify the key and the second string shall specify the certificate. If the
			fourth child, if present, returned either true or a string, the server shall be made
			publicly accessible on the internet, at the specifying domain if a valid domain was
			specified by said returned string, and by a randomly generated domain if not, in which
			case said generated domain shall be logged to the console.
			
			Each route defining list shall have at least three elements, the first and the second
			of which shall be strings, and the third of which shall be a list, and they may also
			have a fourth element which shall be a boolean. The first string shall specify the
			request method, and the second string shall specify the request route. The nested list
			shall specify a Kaeon FUSION function that takes an HTTP request as a dynamic list
			corresponding to said request in HTTP JSON format and shall return either a null value
			or an HTTP response, which may either be in string format or in HTTP JSON formatted as
			a dynamic list. The fourth element, if present and false, shall indicate that the route
			is not to be accessible via CORS.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 3 - Delete ]#

Delete

	Philosophy
	
		-
			The delete command contains the content "Delete". It has one child which returns a
			string in the form of a file or directory path.
			
			It will delete the file or directory at the returned path from the file system.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 4 - Directory ]#

Directory

	Philosophy
	
		-
			The directory command contains the content "Directory". Is has one child that returns a
			string in the form of a directory path.
			
			It will return a list containing two lists, the first of which contains the names of
			all of the directories within the returned directory and the second of which contains
			the names of all of the files within the returned directory.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 5 - Local Directory ]#

Local Directory

	Philosophy
	
		-
			The local directory command contains the content "Local Directory".
			
			It returns the path of the directory the host environment is running out of.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 6 - Root Directories ]#

Root Directory

	Philosophy
	
		-
			The root directories command contains the content "Root Directories".
			
			It returns the paths of the root directories of the system that Kaeon FUSION is running
			on.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 7 - Parent Directory ]#

Parent Directory

	Philosophy
	
		-
			The parent directory command contains the content "Parent Directory". It has one child
			that returns a string in the form of a directory path, and it may optionally have a
			second child that returns an integer number.
			
			If it has no second child, it will return the path of the parent directory of the
			returned directory. If it does have a second child, it will bubble up the directory
			tree for the number of times specified by the returned number and return the path of
			the resulting directory. If it attempts to access the parent of the root directory, it
			will return the root directory.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 8 - Absolute Path ]#

Absolute Path

	Philosophy
	
		-
			The absolute path command contains the content "Absolute". Is has one child that
			returns a string in the form of a file or directory path.
			
			It will return the absolute path to the file at the returned path.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 5 - IO: 9 - Create Directory ]#

Create Directory

	Philosophy
	
		-
			The create directory command contains the content "Create Directory". Is has one child
			that returns a string in the form of a directory path.
			
			If the directory specified by the returned path does not exist, the command will create
			it.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 1 - List ]#

List
	
	Philosophy
	
		-
			The list command contains the content "List".
			
			It returns a list containing all of the values returned by its children.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 10 - Contains ]#

Contains
	
	Philosophy
		
		-
			The contains command contains the content "Contains". It has two children, the first of
			which returns a list and the second of which returns an object.
			
			It will return the true if the list contains the object.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 11 - Index ]#

Index
	
	Philosophy
		
		-
			The index command contains the content "Index". It may have between two and three
			children, the first of which returns a list, the second of which returns an object, and
			the third of which, if present, returns an integer.
			
			It will return the index of the first instance of an object equal to the specified
			object within the list with an index greater or equal to one if the third child is not
			present, or with an index greater than or equal to the number returned by the third
			child if said child is present. If no such object is found, the command will return
			zero.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 12 - Count ]#

Count
	
	Philosophy
		
		-
			The count command contains the content "Count". It will have two children, the first of
			which returns a list, and the second of which returns an object.
			
			It will return the the number of times that an object equal to the specified object
			appears within the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 13 - Cut ]#

Cut
	
	Philosophy
		
		-
			The cut command contains the content "Cut". It will have two children, the first of
			which returns a list, and the second of which returns an object.
			
			It will split the list into several sublists based on the specified object and return
			the sublists as a list. If the list is in the form of a string and the object's string
			form is in the form of a regular expression, the string will be split based on said
			regular expression.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 14 - Reverse ]#

Reverse
	
	Philosophy
		
		-
			The reverse command contains the content "Reverse". It will have a single child that
			returns a list.
			
			It will return a list with all of the elements of the returned list with their indexes
			reversed.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 15 - Convert Sequence ]#

Convert Sequence
	
	Philosophy
		
		-
			The convert sequence command contains the content "Convert Sequence". It will have one
			child that returns a either a list or a string.
			
			If its child returns a list, it will append each element in the list in order to a
			string and return the string.
			
			If its child returns a string, it will append each character in the string in order to
			a list and return the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 16 - List to Element ]#

List to Element

	Philosophy
	
		-
			The list to element command contains the content "List to Element". It must have one
			child that returns a list.
			
			It will make a copy of the list. If the copy is either empty or the string form of its
			first object is not in the form of an empty string, an empty string will be appended to
			the beginning of the list. It will interpret the copied list using ONE list form as an
			element, and return a string containing the interpreted element written using the
			standard ONE language.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 17 - Element to List ]#

Element to List

	Philosophy
	
		-
			The element to list command contains the content "Element to List". It must have one
			child that returns a string containing a ONE+ document.
			
			It will parse the document and return a list representing the document in ONE list
			form.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 18 - Tokenize ]#

Tokenize

	Philosophy
	
		-
			The tokenize command contains the content "Tokenize". It will have at least one child,
			the first of which return a list.
			
			It will split the list into several sublists with sublists being formed from each
			sub-sequence of the list that matches of the object returned by the children following
			the first child and each sub-sequence that occurs between the aforementioned
			sub-sequences. Said sub-sequences will then be returned as a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 19 - Append All ]#

Append All
	
	Philosophy
		
		-
			The append all command contains the content "Append All". It may have two or more
			children. Its first child will return a list, and every subsequent child will return a
			list.
			
			The contents of each returned list with the exception of the first list will, in the
			order their respective lists were returned, be appended to the first list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 2 - Size ]#

Size
	
	Philosophy
		
		-
			The size command contains the content "Size". It has one child that returns a list.
			
			It will return the size of the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 20 - Insert All ]#

Insert All
	
	Philosophy
		
		-
			The insert all command contains the content "Insert All". It must have at least three
			children, the first of which returns a list, the second of which returns an integer,
			and every subsequent child returning a list.
			
			It will insert the contents of the lists returned by the every child past the second
			child in the order their respective lists were returned into the list returned by the
			first child at the index specified by the integer returned by the second child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 21 - Indexes ]#

Indexes
	
	Philosophy
		
		-
			The indexes command contains the content "Indexes". It may have between two and three
			children, the first of which returns a list, the second of which returns an object, and
			the third of which, if present, returns an integer.
			
			It will return a list of the indexes of every instance of an object equal to the
			specified object within the list with an index greater or equal to one if the third
			child is not present, or with an index greater than or equal to the number returned by
			the third child if said child is present.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 22 - Swap ]#

Swap

	Philosophy
		
		-
			The swap command contains the content "Swap". It has three children, the first or which
			returns a list, and the second and third of which return integer numbers.
			
			It will swap the elements of the list at the indexes specified by the returned numbers.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 23 - Sort Alphabetical ]#

Sort Alphabetical

	Philosophy
		
		-
			The sort alphabetical command contains the content "Sort Alphabetical". It may have
			either one or two children, the first of which returns a list and the second of which,
			if present, returns an integer number.
			
			If the second child is not present, the elements of the returned list will be sorted in
			alphabetical order by their string forms. If the second child is present, it is assumed
			that every element in the returned list is a list. The lists will be sorted in
			alphabetical order by the string forms of the element within them at the index
			specified by the returned number. The sorted list will then be returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 24 - Sort Numerical ]#

Sort Numerical

	Philosophy
		
		-
			The sort numerical command contains the content "Sort Numerical". It may have either
			one or two children, the first of which returns a list and the second of which, if
			present, returns an integer number.
			
			If the second child is not present, the elements of the returned list will be sorted in
			numerical order by their string forms. If the second child is present, it is assumed
			that every element in the returned list is a list. The lists will be sorted in
			numerical order by the string forms of the element within them at the index specified
			by the returned number. The sorted list will then be returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 25 - Shuffle ]#

Shuffle

	Philosophy
	
		-
			The shuffle command contains the content "Shuffle". It has one child which returns a
			list.
			
			It will shuffle the order of the elements in the list randomly and return the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 26 - Is Sorted Alphabetical ]#

Is Sorted Alphabetical

	Philosophy
	
		-
			The is sorted alphabetical command contains the content "Is Sorted Alphabetical". Its
			first child returns a list, and may optionally have a second child that returns an
			integer number.
			
			If the second child is not present, it will check to see if the list is sorted in
			alphabetical order by the string forms of its elements, returning true if so and false
			otherwise. If the second child is present, it will be assumed that each element in the
			list is a list, and the command will check to see if the list is sorted in alphabetical
			order by the string forms of the element in each list at the index specified by the
			returned number, returning true if so and false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 27 - Is Sorted Numerical ]#

Is Sorted Numerical

	Philosophy
	
		-
			The is sorted numerical command contains the content "Is Sorted Numerical". Its first
			child returns a list, and may optionally have a second child that returns an integer
			number.
			
			If the second child is not present, it will check to see if the list is sorted in
			numerical order by the string forms of its elements, returning true if so and false
			otherwise. If the second child is present, it will be assumed that each element in the
			list is a list, and the command will check to see if the list is sorted in numerical
			order by the string forms of the element in each list at the index specified by the
			returned number, returning true if so and false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 28 - Key Index ]#

Key Index

	Philosophy
	
		-
			The key index command contains the content "Key Index". It may have either two or three
			children, the first of which returns a list where each element is a list, the second of
			which returns an object, and the third of which, if present, returns an integer number.
			
			It will return the index of the first list in the returned list that contains an object
			equivalent to the returned object. If the third child is present, said object must be
			located at the index specified by the returned number. If no such list is found, it
			will return zero.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 29 - Key Indexes ]#

Key Index

	Philosophy
	
		-
			The key index command contains the content "Key Index". It may have either two or three
			children, the first of which returns a list where each element is a list, the second of
			which returns an object, and the third of which, if present, returns an integer number.
			
			It will return a list of the indexes of each list in the returned list that contains an
			object equivalent to the returned object. If the third child is present, said object
			must be located at the index specified by the returned number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 3 - At ]#

At
	
	Philosophy
		
		-
			The at command contains the content "At". It has at least two children, the first of
			which returns a list, and the rest of which return integers.
			
			For every returned integer in the order they were returned, starting with the returned
			list, it retrieves the object in the list at the index specified by the integer, and
			repeats the process with the next integer, if there is one, on the returned object if
			said object is a list, and when finished returns the final retrieved object.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 30 - Replace ]#

Replace

	Philosophy
	
		-
			The replace command contains the content "Replace". It has three children, the first of
			which returns a list, and the rest of which return objects.
			
			It replaces every instance of the object returned by the second child in the list with
			the object returned by the third child, and returns the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 31 - Rank ]#

Rank

	Philosophy
	
		-
			The rank command contains the content "Rank". It must have a single child that returns
			a list.
			
			It will isolate every unique value in the list and place each unique value into a list
			with the other unique values that occur the same number of times as itself. It will
			then place each list into a new list in the order from the values that occur the least
			to the value that occur the most. It will then return the new list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 32 - Set Alias ]#

Set Alias

	Philosophy

		-
			The set alias command contains the content "Set Alias". It has three children, the
			first of which returns a list, the second of which returns a number corresponding to an
			index within said list, and the third of which returns a string.

			It sets the alias of the element in the returned list specified by the returned number
			to the returned string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 33 - Get By Alias ]#

Get By Alias

	Philosophy

		-
			The get by alias command contains the content "Get By Alias". It has two children, the
			first of which returns a list, and the second of which returns a string containing a
			regular expression.

			It returns every element in the list with an alias matching the regular expression
			specified by the returned string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 34 - Get Alias Indices ]#

Get Alias Indices

	Philosophy

		-
			The get alias indices command contains the content "Get Alias Indices". It has two
			children, the first of which returns a list, and the second of which returns a string
			containing a regular expression.

			It returns a list containing all the indices of elements in the returned list with
			aliases matching the regular expression specified by the returned string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 35 - Get Alias ]#

Get Alias

	Philosophy

		-
			The get alias command contains the content "Get Alias". It has two children, the first
			of which returns a list and the second of which returns an number corresponding to an
			index within said list.

			It returns the alias of the element in the returned list at the index specified by the
			returned number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 36 - JSON to Dynamic List ]#

JSON to Dynamic List

	Philosophy

		-
			The JSON to dynamic list command is a command with the content "JSON to Dynamic List".
			It shall have one child which returns a JSON string.

			It shall return a dynamic list corresponding to the specified JSON.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 37 - Dynamic List to JSON ]#

Dynamic List to JSON

	Philosophy

		-
			The dynamic list to JSON command is a command with the content "Dynamic List to JSON".
			It shall have one child which returns a dynamic list.

			It shall return a JSON string corresponding to the specified dynamic list, where any
			list that has at least one non-null field alias shall become an object, and where any
			list that has no non-null field aliases shall remain a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 4 - Append ]#

Append
	
	Philosophy
		
		-
			The append command contains the content "Append". It may have two or more children. Its
			first child will return a list, and every subsequent child will return an object.
			
			Each returned object will, in the order it was returned, be appended to the list
			returned by the first child. The list will then be returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 5 - Set ]#

Set
	
	Philosophy
		
		-
			The Set command contains the content "Set". It has three children, the first of which
			returns a list, the second of which returns an integer, and the third of which returns
			an object.
			
			It will set the value in the list returned by the first child at the index specified by
			the integer returned by the second child to the object returned by the third child. The
			list will then be returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 6 - Insert ]#

Insert
	
	Philosophy
		
		-
			The insert command contains the content "Insert". It must have at least three children,
			the first of which returns a list, the second of which returns an integer, and every
			subsequent child returning an object.
			
			It will insert the objects returned by the every child past the second child in the
			order they were returned into the list returned by the first child at the index
			specified by the integer returned by the second child. The list will then be returned.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 7 - Remove ]#

Remove
	
	Philosophy
		
		-
			The remove command contains the content "Remove". It has two children, the first of
			which returns a list, and the second of which returns an integer.
			
			It will remove the object in the list returned by the first child at the index
			specified by the integer returned by the second child. If the list is in the form of a
			string, it will return the list, and will return the removed object otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 8 - Concatenate ]#

Concatenate
	
	Philosophy
		
		-
			The concatenate command contains the content "Concatenate". It may have an indefinite
			number of children, each of which returns a list.
			
			It will concatenate the content of each list into a single list, according to the order
			of the children that returned them, and return the list. If the first returned list was
			in the form of a string, the list will be returned in the form of a string, and
			returned in the form of a list otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 6 - List: 9 - Crop ]#

Crop
	
	Philosophy
		
		-
			The crop command contains the content "Crop". It will have between two and three
			children, the first of which returns a list and the second of which, and the third of
			which if present, return numbers.

			The number retruned by the second child is referred to as the second number, and the
			numberreturned by the third child is referred to as the third number. If the third
			child is not present, the third number shall be equal to the length of the list plus
			one.
			
			If the second and third number are equal it will return an empty list.
			
			If the second number is less than the third number, it will run through the list from
			the index specified by the second number to one less than the index specified by the
			third number, appending each element it runs through to a new list. It will then return
			the new list.
			
			If the second number is greater than the third number, it will run through the list
			from the index specified by the third number to one greater than the index specified by
			the second number, appending each element it runs through to a new list. It will then
			return the new list.
			
			If the returned list list was in the form of a string, the generated list will be
			returned as a string. Otherwise, it will be returned as a list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 1 - Character to Number ]#

Character to Number
	
	Philosophy
		
		-
			The character to number command contains the content "Character to Number". It has one
			child that returns a string.
			
			It will return the ASCII value of the first character in the string.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 2 - Number to Character ]#

Number to Character
	
	Philosophy
		
		-
			The number to character command contains the content "Number to Character". It has one
			child that returns a positive integer number.
			
			It will return the character that corresponds to the ASCII value of the number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 3 - Upper ]#

Upper
	
	Philosophy
		
		-
			The upper command contains the content "Upper". It has one child that returns a string.
			
			It will return a string that matches the returned string where all alphabetic
			characters have been converted to upper case.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 4 - Lower ]#

Lower
	
	Philosophy
		
		-
			The lower command contains the content "Lower". It has one child that returns a string.
			
			It will return a string that matches the returned string where all alphabetic
			characters have been converted to lower case.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 5 - Trim ]#

Trim
	
	Philosophy
		
		-
			The trim command contains the content "Trim". It has one child that returns a string.
			
			It will return a string that matches the returned string where all leading and trailing
			whitespace is removed.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 7 - String: 6 - Pattern Match ]#

Pattern Match

	Philosophy
	
		-
			The pattern match command contains the content "Pattern Match". It has two children,
			the first of which returns a string and the second of which returns a string in the
			form of a regular expression.
			
			It will return true if the first string matches the regular expression defined by the
			second string, and will return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 1 - Not ]#

Not
	
	Philosophy
		
		-
			The not command contains the content "Not". It has one child that returns a boolean.
			
			It will return true if the returned boolean has a value of false, and return false if
			the returned boolean has a value of true.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 10 - Less or Equal ]#

Less or Equal
	
	Philosophy
		
		-
			The less or equal command contains the content "Less or Equal". It may have an
			indefinite number of children, each of which return a number.
			
			It will return true if the number returned by the every child except for the last child
			is less than or equal to than the number returned by the following child, and return
			false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 2 - Is ]#

Is
	
	Philosophy
		
		-
			The is command contains the content "Is". It has two children.
			
			It will true if the objects returned by all of its children are the same object, and
			false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 3 - Equal ]#

Equal
	
	Philosophy
		
		-
			The equal command contains the content "Equal". It has two children.
			
			It will return true if the string form of the objects returned by both of its children
			are equal, and return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 4 - And ]#

And
	
	Philosophy
		
		-
			The and command contains the content "And". It may have an indefinite number of
			children, each of which return a boolean.
			
			It will return true if all of the returned booleans are true, and return false
			otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 5 - Or ]#

Or

	Philosophy
		
		-
			The or command contains the content "Or". It may have an indefinite number of children,
			each of which return a boolean.
			
			It will return true if any of the returned booleans are true, and return false
			otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 6 - Exclusive Or ]#

Exclusive Or

	Philosophy
		
		-
			The exclusive or command contains the content "Exclusive Or". It may have an indefinite
			number of children, each of which return a boolean.
			
			It will return true if exactly one of the returned booleans are true, and return false
			otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 7 - Greater ]#

Greater
	
	Philosophy
		
		-
			The greater command contains the content "Greater". It may have an indefinite number of
			children, each of which return a number.
			
			It will return true if the number returned by the every child except for the last child
			is greater than the number returned by the following child, and return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 8 - Greater or Equal ]#

Greater or Equal
	
	Philosophy
		
		-
			The greater or equal command contains the content "Greater or Equal". It may have an
			indefinite number of children, each of which return a number.
			
			It will return true if the number returned by the every child except for the last child
			is greater than or equal to than the number returned by the following child, and return
			false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 8 - Logic: 9 - Less ]#

Less
	
	Philosophy
		
		-
			The less command contains the content "Less". It may have an indefinite number of
			children, each of which return a number.
			
			It will return true if the number returned by the every child except for the last child
			is less than the number returned by the following child, and return false otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 1 - Add ]#

Add
	
	Philosophy
		
		-
			The add command contains the content "Add". It may have an indefinite number of
			children, each of which return a number.
			
			It returns the sum of all the numbers.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 10 - Cosine ]#

Cosine
	
	Philosophy
		
		-
			The cosine command contains the content "Cosine". It must have a single child which
			returns a number.
			
			It returns the cosine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 11 - Tangent ]#

Tangent
	
	Philosophy
		
		-
			The tangent command contains the content "Tangent". It must have a single child which
			returns a number.
			
			It returns the tangent value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 12 - Square Root ]#

Square Root
	
	Philosophy
		
		-
			The square root command contains the content "Square Root". It must have a single child
			which returns a number.
			
			It returns the square root of the returned number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 13 - Natural Logarithm ]#

Natural Logarithm
	
	Philosophy
		
		-
			The natural logarithm command contains the content "Natural Logarithm". It must have a
			single child which returns a number.
			
			It returns the natural logarithm of the returned number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 14 - Floor ]#

Floor
	
	Philosophy
		
		-
			The floor command contains the content "Floor". It must have a single child which
			returns a number.
			
			It returns the value of the returned number rounded down.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 15 - Ceiling ]#

Ceiling
	
	Philosophy
		
		-
			The ceiling command contains the content "Ceiling". It must have a single child which
			returns a number.
			
			It returns the value of the returned number rounded up.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 16 - To Radians ]#

To Radians
	
	Philosophy
		
		-
			The to radians command contains the content "To Radians". It must have a single child
			which returns a number.
			
			It converts the returned number from a degrees value to a radians value and returns the
			resulting value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 17 - To Degrees ]#

To Degrees
	
	Philosophy
		
		-
			The to degrees command contains the content "To Degrees". It must have a single child
			which returns a number.
			
			It converts the returned number from a radians value to a degrees value and returns the
			resulting value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 18 - Absolute Value ]#

Absolute Value
	
	Philosophy
		
		-
			The absolute value command contains the content "Absolute Value". It must have a single
			child which returns a number.
			
			It returns the absolute value of the returned number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 19 - Infinity ]#

Infinity
	
	Philosophy
		
		-
			The infinity command contains the content "Infinity".
			
			It returns a value of infinity.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 2 - Subtract ]#

Subtract
	
	Philosophy
		
		-
			The subtract command contains the content "Subtract". It may have an indefinite number
			of children, each of which return a number.
			
			It subtracts each number following the first number from the first number and returns
			the resulting value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 20 - Arc Sine ]#

Arc Sine
	
	Philosophy
		
		-
			The arc sine command contains the content "Arc Sine". It must have a single child which
			returns a number.
			
			It returns the arc sine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 21 - Arc Cosine ]#

Arc Cosine
	
	Philosophy
		
		-
			The arc cosine command contains the content "Arc Cosine". It must have a single child
			which returns a number.
			
			It returns the arc cosine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 22 - Arc Tangent ]#

Arc Tangent
	
	Philosophy
		
		-
			The arc tangent command contains the content "Arc Tangent". It must have a single child
			which returns a number.
			
			It returns the arc tangent value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 23 - Hyperbolic Sine ]#

Hyperbolic Sine
	
	Philosophy
		
		-
			The hyperbolic sine command contains the content "Hyperbolic Sine". It must have a
			single child which returns a number.
			
			It returns the hyperbolic sine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 24 - Hyperbolic Cosine ]#

Hyperbolic Cosine
	
	Philosophy
		
		-
			The hyperbolic cosine command contains the content "Hyperbolic Cosine". It must have a
			single child which returns a number.
			
			It returns the hyperbolic cosine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 25 - Hyperbolic Tangent ]#

Hyperbolic Tangent
	
	Philosophy
		
		-
			The hyperbolic tangent command contains the content "Hyperbolic Tangent". It must have
			a single child which returns a number.
			
			It returns the hyperbolic tangent value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 26 - Theta ]#

Theta
	
	Philosophy
		
		-
			The theta command contains the content "Theta". It must have two children, each of
			which return a number.
			
			It returns the theta component, in radians, of the polar coordinate equivalent for the
			cartesian coordinate where the number returned by the first child is the x value and
			the number returned by the second child is the y value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 27 - Maximum ]#

Maximum

	Philosophy
	
		-
			The maximum command contains the content "Maximum". It must have a single child that
			returns a list of numbers.
			
			It returns the number in the list with the highest value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 28 - Minimum ]#

Minimum

	Philosophy
	
		-
			The minimum command contains the content "Minimum". It must have a single child that
			returns a list of numbers.
			
			It returns the number in the list with the lowest value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 29 - Mean ]#

Mean

	Philosophy
	
		-
			The mean command contains the content "Mean". It must have a single child that returns
			a list of numbers.
			
			It returns the mean of all the numbers in the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 3 - Multiply ]#

Multiply
	
	Philosophy
		
		-
			The multiply command contains the content "Multiply". It may have an indefinite number
			of children, each of which return a number.
			
			It returns the product of all the numbers.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 30 - Median ]#

Median

	Philosophy
	
		-
			The median command contains the content "Median". It must have a single child that
			returns a list of numbers.
			
			It returns the median of all the numbers in the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 31 - Range ]#

Range

	Philosophy
	
		-
			The range command contains the content "Range". It must have a single child that
			returns a list of numbers.
			
			It returns the value of the highest number in the list minus the lowest number.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 32 - Summation ]#

Summation

	Philosophy
	
		-
			The summation command contains the content "Summation". It must have a single child
			that returns a list of numbers.
			
			It returns the sum of all the numbers in the list.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 33 - Decimal to Binary ]#

Decimal to Binary

	Philosophy
	
		-
			The decimal to binary command contains the content "Decimal to Binary". It must have
			three children, the first of which returns a number, and the second and third of which
			return booleans.
			
			It returns a string containing the binary representation of the returned number. If the
			boolean returned by the second child is true, the number will be represented as a
			signed number, and unsigned otherwise. If the boolean returned by the third child is
			true, the number will be represented as a floating point number, and as an integer
			otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 34 - Decimal to Hexadecimal ]#

Decimal to Hexadecimal

	Philosophy
	
		-
			The decimal to hexadecimal command contains the content "Decimal to Hexadecimal". It
			must have three children, the first of which returns a number, and the second and third
			of which return booleans.
			
			It returns a string containing the hexadecimal representation of the binary form of the
			returned number. If the boolean returned by the second child is true, the number will
			be represented as a signed number, and unsigned otherwise. If the boolean returned by
			the third child is true, the number will be represented as a floating point number, and
			as an integer otherwise.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 35 - Binary to Decimal ]#

Binary to Decimal

	Philosophy
	
		-
			The binary to decimal command contains the content "Binary to Decimal". It must have
			three children, the first of which returns a string containing a binary representation
			of a number, and the second and third of which return booleans.
			
			It returns a number that is equivalent to the binary value represented by the returned
			string. The number shall be assumed to be signed if the first boolean is true and shall
			be assumed to be floating point if the second boolean is true.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 36 - Hexadecimal to Decimal ]#

Hexadecimal to Decimal

	Philosophy
	
		-
			The hexadecimal to decimal command contains the content "Hexadecimal to Decimal". It
			must have three children, the first of which returns a string containing a hexadecimal
			representation of a binary number, and the second and third of which return booleans.
			
			It returns a number that is equivalent to the binary value represented by the returned
			hexadecimal string. The number shall be assumed to be signed if the first boolean is
			true and shall be assumed to be floating point if the second boolean is true.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 37 - Binary to Hexadecimal ]#

Binary to Hexaecimal

	Philosophy
	
		-
			The binary to hexadecimal command contains the content "Binary to Hexadecimal". It has
			one child that return a value, the string form of which contains a binary
			representation of a number.

			It returns a string containing the value specified in binary by the string form of the
			returned value in hexadecimal format.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 38 - Hexadecimal to Binary ]#

Hexaecimal to Binary

	Philosophy
	
		-
			The hexadecimal to binary command contains the content "Hexadecimal to Binary". It has
			one child that return a value, the string form of which contains a hexadecimal
			representation of a number.

			It returns a string containing the value specified in hexadecimal by the string form of
			the returned value in binary format.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 4 - Divide ]#

Divide
	
	Philosophy
		
		-
			The divide command contains the content "Divide". It may have an indefinite number of
			children, each of which return a number.
			
			It assigns the first number to a value and divides the value by each subsequent number
			in order. It then returns the resulting value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 5 - Modulus ]#

Modulus
	
	Philosophy
		
		-
			The modulus command contains the content "Modulus". It may have an indefinite number of
			children, each of which return a number.
			
			It assigns the first number to a value and for each subsequent number in order assigns
			the remainder of the division of the value and the respective number to the value. It
			then returns the resulting value.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 6 - Random ]#

Random
	
	Philosophy
		
		-
			The random command contains the content "Random".
			
			It returns a random number between zero and one.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 7 - Negative ]#

Negative
	
	Philosophy
		
		-
			The negative command contains the content "Negative". It must have a single child which
			returns a number.
			
			It returns the product of the returned number and negative one.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 8 - Power ]#

Power
	
	Philosophy
		
		-
			The power command contains the content "Power". It must have two children, each of
			which return a number.
			
			It returns the value of the number returned by its first child raised to the power of
			the number returned by its second child.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 1 - Kaeon FUSION Interfaces: 1 - Standard: 1 - Commands: 2 - Defined: 9 - Math: 9 - Sine ]#

Sine
	
	Philosophy
		
		-
			The sine command contains the content "Sine". It must have a single child which returns
			a number.
			
			It returns the sine value of the returned number in radians.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 1 - ONE Dialects: 1 - Conversions: 1 - ONE Conversions ]#

ONE Conversions

	Philosophy

		-
			A ONE document can be represented using the formats of other markup languages.
		-
	
	Principles

		JSON

			-
				A ONE document can be represented in JSON using ONE list form, where the elements
				are encoded as JSON lists and element content is encoded as JSON strings.
			-

		XML

			-
				A ONE document can be represented in XML with the tags "Element" and "Content",
				where letter case is irrelevant.

				An element tag represents a ONE element and may contain an indefinite number of
				other element tags and may also contain one content tag.

				A content tag must be the child of an element tag, and may contain a string
				representing the content of its parent, which if not present, indicates that its
				parent contains an empty string as its content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 1 - ONE Dialects: 2 - Syntaxes: 1 - Zero ]#

Zero

	Philosophy
	
		-
			Zero is a file format for encoding a ONE document in a way that optimizes the speed at
			which data can be extracted and encoded.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 1 - ONE Dialects: 2 - Syntaxes: 2 - ONE LISP ]#

ONE LISP

	Philosophy
	
		-
			ONE LISP is an alternate syntax for encoding a ONE document that resembles LISP.
		-
	
	Principles
		
		Structure
		
			-
				The document represents a list in ONE list form representing an element with no
				content. All elements at the root of the document are implicitly assumed to be in a
				list. 
			-
		
		Syntax
		
			-
				A sequence located outside a quoted literal beginning with a pound sign where said
				pound sign is not immediately followed by a square bracket and ending with a new
				line will be a comment.
				
				A sequence located outside a quoted literal beginning with a pound sign followed by
				a square bracket and ending with a square bracket followed by a pound sign will be
				a comment.
				
				An open parenthesis denotes the beginning of a list.
				
				A closed parenthesis denotes the end of a list.
				
				Sequences located between double quotes will be interpreted as literals where both
				of said double quotes are present.
				
				Sequences located between single quotes will be interpreted as literals where both
				of said single quotes are absent.
				
				Any contiguous sequence located outside of comments and quoted literals that does
				not contain whitespace, parentheses, single quotes, double quotes, or pound signs
				will be interpreted as a literal.
				
				Whitespace will separate said literal values.
				
				A sequence occurring within a literal that consists of a backslash followed by an
				'n' will be interpreted as a new line character.
				
				A sequence occurring within a literal that consists of a backslash followed by a
				't' will be interpreted as a tab character.
				
				If a backslash precedes an operator character, including another backslash, the
				effect of the operator character will be nullified and the operator will be
				interpreted literally.
				
				The end of the file may be interpreted as the end of a list, quoted literal, or
				comment.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 1 - ONE Dialects: 2 - Syntaxes: 3 - ONE SOUL ]#

ONE SOUL

	Philosophy
	
		-
			ONE SOUL is an alternate syntax for encoding a ONE document that allows the user to
			dictate their code in natural language and allow an AI to convert said language to ONE
			elements.
		-
	
	Principles
	
		Corpus
		
			-
				The file that stores the corpus used to perform the conversion will be stored in a
				file called "ONE SOUL.op", and will contain two elements, one with the content
				"Model", which will have a child containing the name of the SOUL core model to be
				used, and an element with the content "Corpus", which will have as its children the
				contents of a SOUL core format document.
			-
		
		Processing
		
			-
				The entire file will be processed to ONE+ at once using the model and corpus
				provided by the corpus file.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 1 - ONE Dialects: 3 - Super Mode ]#

Super Mode
	
	Philosophy
		
		-
			Super Mode is an alternate syntax for Kaeon FUSION code that serves to allow for infix
			notation and to reduce verbosity.
		-
	
	Principles
		
		Effects
			
			Interfaces
				
				-
					Super Mode will automatically enable the Standard interface and the Stack
					interface.
				-
			
			Super Tokens
				
				-
					Super tokens are tokens that may be placed within the content of elements.
					
					If a token is not surrounded by double quotes, it will be processed. Certain
					tokens will take priority in the order they are processed if they occur within
					the same element. If multiple tokens have equivalent priority, they will be
					processed from left to right. If a token requires a value it cannot locate, it
					will not be processed. The letter case of a token is irrelevant.
					
					Upon being processed, a token will separate the content that precedes it into a
					left hand value and the content that follows it into a right hand value. Both
					the left hand value and the right hand value will be trimmed of any leading or
					trailing whitespace. If the resulting left hand value has a length of zero, the
					element preceding the element containing the token may serve as the left hand
					value for certain tokens. If the resulting right hand value has a length of
					zero, the element following the element containing the token, or the children
					of the element containing the token, in which case there will be multiple right
					hand values, may serve as the right hand value depending on the token.
					
					Once processed into a left hand value, a token, and a right hand value, an
					effect will be applied depending on the token.
				-
				
				Token Conflicts
				
					-
						If the content of an element matches the name of a command in the standard
						interface or stack interface, or if an element is a directive, any tokens
						within said element will not be processed.
						
						If one token consists of another token followed by an additional sequence
						of characters, the larger token will take priority.
						
						Certain tokens referred to as isolated tokens will only be recognized if
						they are preceded by either the beginning of their element's content or by
						whitespace, and followed either by the end of their element's content or by
						whitespace.
					-
				
				Tokens
				
					First Priority
					
						Abs
						Cos
						Def
						Define
						Elif
						Else
						For
						For Each
						For Range
						Global
						If
						Import
						Log
						Log Line
						LogN
						New
						Params
						Print
						Return
						Sin
						Sqrt
						Tan
						While
						
					Second Priority
					
						=
						&=
						+=
						-=
						*=
						/=
						%=
						
					Third Priority
					
						And
						Not
						Or
						Xor
						
					Fourth Priority
					
						==
						!=
						>
						>=
						<
						<=
						
					Fifth Priority
					
						->
						=>
						|
						@
						++
						--
					
					Sixth Priority
					
						&
						+
						-
					
					Seventh Priority
					
						**
						*
						/
						%
				
				Effects
					
					Function Parameters
					
						-
							The token "params" may be used to specify function parameters if it is
							nested within the child of a define command. It is an isolated token.
							
							This token will use the children of the command it occurs in as
							alternative right hand values.
							
							The content of each of the token's right hand values shall become an
							alias of a parameter for the function corresponding to the order of
							said right hand values.
						-
					
					Implicit Prefix Notation
					
						-
							Certain tokens may be used in place of certain commands where their
							right hand values will serve as arguments. They are all isolated
							tokens.
							
							These tokens will use the children of the command they occur in as
							alternative right hand values.
							
							The log, log line, import, define, else, not, new, global, and return
							commands may all be used in the form of such a token as opposed to a
							command. The token "print" may be used in place of "log line", the
							token "def" may be used in place of "define", the token "Sin" may be
							used in place of "Sine", the token "Cos" may be used in place of
							"Cosine", the token "Tan" may be used in place of "Tangent", the token
							"Abs" may be used in place of "Absolute Value", the token "Sqrt" may be
							used in place of "Square Root", and the token "LogN" may be used in
							place of "Natural Logarithm".
						-
					
					Conditionals and Loops
						
						-
							The following tokens will use the children of the command they occur in
							as alternative right hand values. They are all isolated tokens.
							
							The token "If" with a right hand value in the form of a value that
							returns a boolean translates to a conditional where its children, not
							including said boolean, are processed if said boolean is true.
							
							The token "Elif" with a right hand value in the form of a value that
							returns a boolean translates to a conditional where its children, not
							including said boolean, are processed if said boolean is true and the
							previous conditional failed to activate.
							
							The token "While" with a right hand value in the form of a value that
							returns a boolean followed by the token "Do" translates to a loop where
							its children, not including said boolean, are processed until said
							boolean is false.
							
							The token "For" with at least one right hand value in the form of a
							value that returns a number translates to a loop where its children,
							not including the first right hand value, are processed for the number
							of times returned by said number.
							
							The token "For Each" with at the least two right hand values, the first
							of which may have any content and the second of which returns a list
							translates to a loop where its children, not including the first two
							right hand values, are processed once for every element in the returned
							list and content of the first right hand value serves as the alias for
							the element in the list at the index corresponding to the current
							iteration.
							
							The token "For Range" with at the least three right hand values, the
							first of which may have any content and the second and third of which
							returns numbers, translates to a loop where its children, not including
							the first three right hand values, are processed once for every number
							between the two returned numbers, inclusive, and the miscellaneous
							string serves as the alias for the number corresponding to the current
							iteration.
						-
					
					Infix Operators
						
						-
							An infix operator token will take its left hand value and its right
							hand values, and make them the children of the command containing it,
							with the left hand value preceding the right hand values. The token
							will then be replaced with a standard interface command.
							
							These tokens will use the siblings of the command they occur in as
							alternative left hand values and right hand values.
							
							The tokens recognized as infix operators are listed below along with
							their respective standard interface commands:
							
							&: Concatenate
							@: At
							And: And
							Or: Or
							Xor: Exclusive Or
							>: Greater
							>=: Greater or Equal
							<: Less
							<=: Less or Equal
							==: Equal
							!=: Not: Equal
							**: Power
							*: Multiply
							/: Divide
							%: Modulus
							+: Add
							-: Subtract
							
							The token "-=" indicates the presence of a command that deprecates its
							left hand value by its right hand value.
							
							The token "+=" indicates the presence of a command that increments its
							left hand value by its right hand value.
							
							The token "*=" indicates the presence of a command that multiplies its
							left hand value by its right hand value.
							
							The token "/=" indicates the presence of a command that divides its
							left hand value by its right hand value.
							
							The token "%=" indicates the presence of a command that modulos its
							left hand value by its right hand value.
							
							The token "&=" indicates the presence of a command that concatenates
							its right hand value to its left hand value.
						-
					
					Postfix Operators
						
						-
							The token "--" indicates the presence of a command that deprecates its
							left hand value by one.
							
							The token "++" indicates the presence of a command that increments its
							left hand value by one.
						-
					
					Special Operators
					
						-
							The token "=" translates to a command that assigns the right hand value
							to a variable with an alias match its left hand value.
							
							The token "->" translates to a command that performs the functions
							specified by its right hand values within the object specified by its
							left hand value. It will use the children of the element it occurs in
							as alternative right hand values.
							
							The token "=>" translates to a command that returns the variable
							specified by its right hand value from within the object specified by
							its left hand value.
							
							The token "|" translates to performing the commands specified by its
							left hand value with its right hand values as its first argument and
							the children of the command containing it as additional arguments. It
							will use the children of the element it occurs in as alternative right
							hand values.
						-

		Standard+

			-
				Standard+ is when super mode is active by default when interpreting Kaeon FUSION
				code.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect ]#

Build Dialect

	Philosophy
	
		-
			A build dialect is a ONE dialect used to represent another file format.
		-

	Principles

		Meta Command

			Philosophy

				-
					A meta command is a ONE element with the content "Meta".

					A meta command may be placed into a build dialect document to specify
					miscellaneous information to any program interpreting said document using its
					children.
				-
			
			Scope
				
				-
					Any effect specified by a meta command will act on commands that follow said
					command.
					
					An effect of a command is said to have extended scope if said effect trickles
					down to elements within the scope of the affected elements.
					
					A meta command effect is said to have reduced scope if it only applies to the
					element immediately following said command.
					
					If two meta commands specify effects that contradict one another, the effects
					of the more recent command shall be applied.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 1 - Assembly Dialect ]#

Assembly Dialect

	Philosophy
	
		-
			The assembly dialect is a build dialect analogous to machine code.
		-

	Principles
	
		Instructions
		
			-
				Every element in an assembly dialect document that is not a use command or a mode
				command is analogous to a linear sequence of instructions in machine code.
			-

		Size Command

			-
				A size command contains the content "Size", regardless of letter case, and has
				a single child containing an integer number greater than or equal to one, which
				will determine what byte size the instructions following it and preceding the size
				mode command or the end of the file will be encoded with. The size will be set to
				eight by default.
			-
	
		Modes
			
			Mode Command
				
				-
					A mode command contains the content "Mode", regardless of letter case, and has
					a single child containing the content "Binary", "Raw", "Decimal",
					"Hexadecimal", or "Mnemonic", which will determine what mode the instructions
					following it and preceding the next mode command or the end of the file will be
					cross compiled according to. The mode will be set to binary by default.
				-
			
			Binary Mode
			
				-
					An instruction in binary mode is an element which may contain as its content a
					sequence of zeroes and ones, and corresponds literally to a single binary
					instruction.
				-
			
			Raw Mode
			
				-
					An instruction in raw mode is an element which may contain any string as its
					content, corresponding to a sequence of instructions where each character
					corresponds to a binary value.
				-
			
			Decimal Mode
			
				-
					An instruction in decimal mode is an element which may contain as its content a
					decimal number, and corresponds to a single binary instruction such that said
					instruction is the binary form of said number.
				-
			
			Hexadecimal Mode
			
				-
					An instruction in hexadecimal mode is an element which may contain as its
					content a hexadecimal number, and corresponds to a single binary instruction
					such that said instruction is the binary form of said number.
				-
			
			Mnemonic Mode
			
				-
					An instruction in mnemonic mode is an element that may have any content other
					than "Use", "Size", or "Mode", regardless of letter case, and may have any
					children.
				-
		
		Use Command
		
			-
				A use command will have the content "Use", regardless of letter case, and will have
				an indefinite number of children, each of which containing as their content the
				file path of a ONE+ file.
				
				The ONE+ file will be a Kaeon FUSION file using the standard interface that may be
				passed as an argument the contents of an assembly dialect instruction written in
				mnemonic mode in ONE list form, and based on it either return a list of strings
				containing binary corresponding to the compiled instruction, or return null if the
				mnemonic is unrecognized.
				
				If multiple ONE+ files are included through use commands, and more than one of them
				return a non null value for a given mnemonic, the more recently included document
				will take priority.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect ]#

Cross Dialect
	
	Philosophy
		
		-
			A cross dialect is a build dialect that allows code written in the Kaeon FUSION
			standard interface to be translated to another language.
			
			Given that there are certain details some languages may require that would not be
			included in native Standard interface code, meta commands may be used to specify the
			necessary information. As such, a set of meta command formats used for all cross
			dialects has been specified.
			
			Additional meta command notation formats may be added to individual cross dialects to
			cover for features specific to certain languages.
		-
	
	Principles
		
		Structure
			
			Strong Typing
				
				-
					A meta command may have a child with the content "Type". The children of the
					type element will determine the type of any variable declared within the meta
					command's scope.
				-
				
				Casting
					
					-
						A meta command may have a child with the content "Cast". The children of
						the cast element will determine the type that the value returned by the
						command in the meta command's scope will be cast to. This effect will have
						reduced scope.
					-
			
			Arrays
			
				-
					A meta command may have a child with the content "Arrays".
				-
			
				Size
				
					-
						If a meta element has a child with the content "Arrays", said child may
						have a child with the content "Size". The size element may either have a
						child with the content "Fixed", in which case all lists within the meta
						command's scope will be treated as fixed length arrays, or it may have a
						child with the content "Variable", in which case all lists within the meta
						command's scope will be treated as variable length vectors.
						
						By default arrays are assumed to be of variable length.
					-
				
				Index
				
					-
						If a meta element has a child with the content "Arrays", said child may
						have a child with the content "Index". The index element will have a child
						containing an integer number as its content, dictating the starting index
						of all lists in the meta command's scope.
						
						By default arrays are assumed to start at an index of one.
					-
			
			Functions
				
				Function Definitions
					
					-
						A meta command may have a child with the content "Function". If the meta
						command immediately precedes a Define command, the function element's
						children will determine the properties of all of the functions defined by
						said Define command.
					-
				
					Type
					
						-
							If a meta element has a child with the content "Function", said child
							may have use one of the following three ways to declare the type of
							functions declared within the meta command's scope.
							
							The function element may have a child with the content "Type". The
							children of the type element determine the return type of the function.
							
							The function element may have a child with the content "Class". In this
							case, the function definition will serve as the constructor for a class
							definition. Functions defined within the function definitions will
							become methods of the class, and global variables defined within the
							function definitions will become class variables. The class element may
							have an indefinite number of children, each with content specifying the
							names of classes to extend from.
							
							The function element may have a child with the content "Constructor".
							In this case, the function definition will serve as a constructor for
							the class definition it occurs within.
						-
				
					Parameters
					
						-
							If a meta element has a child with the content "Function", said child
							may have use one of the following two ways to declare the parameters of
							functions declared within the meta command's scope.
							
							The function element may have a child with the content "Parameters".
							Each child of the parameters element defines a parameter. The content
							of said child defines the parameter's alias, and its children define
							its type.
							
							Alternatively, The function element may have a child with the content
							"Parameter Number". The parameter number element must have a single
							child with content containing an integer number specifying the number
							of parameters the functions will have.
						-
					
					Inline Functions
					
						-
							The function element may have a child with the content "Inline". In
							this case, the function definition will appear in the cross compiled
							code where it was defined in the original cross dialect code. The
							inline element may have a child with the content "Unaliased", in which
							case the cross compiled function will not have an alias. The cross
							dialect function that corresponds to an unaliased cross compiled
							function must still have an alias, but there will be no issues if it
							shares an alias with other functions.
						-
				
				Host Functions
					
					-
						A meta command may have a child with the content "Host". Any command within
						the meta command's scope with content that matches the content of one of
						the host element's children will be treated as a function call to a
						function with an alias matching its content. This effect will have extended
						scope.
					-
			
			Fields
			
				-
					A meta command may have a child with the content "Field". The field element
					must either have a child with the content "Function", in which case In commands
					within the meta command's scope will only access public functions, or a child
					with the content "Variable", in which case the In commands within the meta
					command's scope will only access public variables.
					
					By default In commands are assumed to only access functions.
				-
		
		Extensions
		
			-
				An extended variant of the cross dialect must specify what languages and frameworks
				the dialect corresponds to, what data types may be used for variables and
				functions, and what may be placed in a notation.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 1 - Primary: 1 - C Dialect ]#

C Dialect
	
	Philosophy
		
		-
			The C dialect is a cross dialect analogous to C.
		-
	
	Types
	
		External
		
		Automatic
		
		Unsigned
		
		Signed
		
		Integer
		
		Short
		
		Long
		
		Float
		
		Double
		
		Character
		
		Boolean
		
		Void
		
		Pointer
		
		Address
		
		Array
			
			-
				If the type element has a child with the content "Array", said child may an
				indefinite number of children, each of which may have either an integer number or
				the string "Null" as their content. Each of said children represents a dimension of
				an array, where a child containing a number represents the length of said dimension
				and a child with the string "Null" represents a dimension of indeterminate length.
				If the array element has no children, the array will be assumed be a one
				dimensional array of indeterminate length.
			-
		
		Structure
		
			-
				If the type element has a child with the content "Structure", said child must have
				a child with content containing the name of a C struct.
			-
		
		Inline Structure
		
			-
				If the type element has a child with the content "Inline Structure", the children
				of said child shall compose the body of a function analogous to a C struct.
			-
	
	Notations
	
		Get Pointer
		
			-
				If a notation element in a meta command contains the content "Get Pointer", the
				command in the meta command's scope will be a pointer reference. This effect will
				have reduced scope.
			-
		
		Get Address
		
			-
				If a notation element in a meta command contains the content "Get Address", the
				command in the meta command's scope will be an address reference. This effect will
				have reduced scope.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 1 - Primary: 2 - JavaScript DIalect ]#

JavaScript Dialect
	
	Philosophy
		
		-
			The JavaScript dialect is a cross dialect analogous to JavaScript and JSON.
		-
	
	Principles
	
		Notations
		
			JavaScript Mode
			
				-
					In the JavaScript dialect, a meta notation may have a child with the content
					"JavaScript Mode". Said child must have a child with either "JavaScript" or
					"JSON" as its content. If the mode is set to JSON, everything within cross
					compiled code generated by the contents of the notation's scope will be cut
					unless it is valid JSON. The mode is set to JavaScript by default.
				-
			
			List Type
			
				-
					In the JavaScript dialect, a meta notation may have a child with the content
					"List Type". Said child must have a child with either "List" or "Object" as its
					content. If the type is list, the lists within the notation's scope may have
					any contents and will be cross compiled as normal JavaScript lists. If the type
					is object, every child of list definitions within the notation's scope must
					have a single child that must either be a string, boolean, or number literal,
					or a list definition. List definitions declared when the type is object will be
					cross compiled to object literals. The type is list by default.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 1 - Java DIalect ]#

Java Dialect
	
	Philosophy
		
		-
			The Java dialect is a cross dialect analogous to Java.
		-
	
	Types
	
		Public
		
		Private
		
		Protected
		
		Package
		
		Static
		
		Final
		
		Object
		
		Byte
		
		Integer
		
		Short
		
		Long
		
		Float
		
		Double
		
		Character
		
		Boolean
		
		Void
		
		Class
		
			-
				If the type element has a child with the content "Class", said child must have a
				single child with content containing an the name of a Java class.
			-
		
		Template
		
			-
				If the type element has a child with the content "Template", said child may have
				any children that the type element itself may have, specifying the type to place
				within a template.
			-
			
		Array
			
			-
				If the type element has a child with the content "Array", said child may have a
				child with content containing an integer number, specifying the dimensions of the
				array. If no such child is present, the array will be assumed to be one
				dimensional.
			-
	
	Operator Commands
	
		Instance Of
		
			-
				The instance of operator command contains the content "Instance Of". It will have
				two children, the first of which may return any Java object value and the second of
				which has content that matches the name of a Java class.
			-
	
	Notations
	
		Package
		
			-
				If a notation element has a child with the content "Package", said child must have
				one child with content containing the name of a java package, which will be the
				package the class it occurs within will be declared to reside in.
			-
		
		Interfaces
		
			-
				If a notation element has a child with the content "Interfaces", said child may
				have an indefinite number of children, each of which with content containing the
				name of a Java interface, which any class definitions following the respective meta
				command will implement.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 2 - Python DIalect ]#

Python Dialect
	
	Philosophy
		
		-
			The Python dialect is a cross dialect analogous to Python.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 3 - C++ Dialect ]#

C++ Dialect
	
	Philosophy
		
		-
			The C++ dialect is a cross dialect analogous to C++.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 4 - C# Dialect ]#

'C# Dialect'
	
	Philosophy
		
		-
			The C# dialect is a cross dialect analogous to C#.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 5 - Swift DIalect ]#

Swift Dialect
	
	Philosophy
		
		-
			The Swift dialect is a cross dialect analogous to Swift.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 6 - PHP Dialect ]#

PHP Dialect
	
	Philosophy
		
		-
			The PHP dialect is a cross dialect analogous to PHP.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 3 - Miscellaneous Dialects: 1 - DOM Dialect ]#

DOM Dialect
	
	Philosophy
		
		-
			The DOM dialect is a build dialect analogous to XML.
		-
	
	Principles
		
		Syntax
			
			Structure
				
				-
					An DOM dialect document will have exactly one XML element at the root level. It
					may also optionally have one or both of a single declaration element and a
					single document element at the root level, as well as an indefinite number of
					use elements.
				-
			
			Letter Case
			
				-
					The letter case of content specified for elements listed in this document is
					irrelevant.
				-
				
			Use Element
			
				-
					A use element has the content "Use". It may have an indefinite number of
					children, each of which having content that specifies the file path of a use
					document.
				-
			
			Use Document
			
				-
					A use document is a ONE document containing elements with either the content
					"Tags" or "Attributes". Each of these elements may have an indefinite number
					of children, with each of said children having one child. No child of a tags or
					attributes element may have the content "Attributes" or "Children".
					
					Any element in an DOM dialect document nested within the scope of the root
					element that matches the content of a child of a tag element in a use document
					referenced by a use command by said DOM dialect document shall function as an
					XML element that translates to an XML tag with a name matching the content of
					the child of said child, even if said element is not nested within a children
					element.
					
					Any element in an DOM dialect document nested within an XML element that
					matches the content of a child of a attributes element in a use document
					referenced by a use command by said DOM dialect document shall function as an
					attribute element that translates to an XML attribute with a name matching the
					content of the child of said child, even if said element is not nested within
					an attributes element.
				-
			
			Declaration Element
				
				-
					The root element has the content "Declaration". It may have one or both or both
					of a child with the content "Encoding" and a child with the content
					"Standalone". The child with the content "Encoding" must have a child with
					content matching the name of a character encoding standard. The child with the
					content "Standalone" must have a child with either "Yes" or "No" as its
					content.
				-
			
			Document Element
				
				-
					The document element has the content "Document". It will have a single child
					which will have content in the form of an XML DTD.
				-
			
			XML Elements
			
				-
					An XML element may have any content, unless it is at the root level of the
					document, in which case it may not have the content "Use", "Declaration", or
					"Document", and it may have an indefinite number of children, each of which
					will take the form of a category element.
					
					The content of the element will be literal content.
				-
			
			Category Elements
				
				-
					A category element will take the form of an attributes element, a data element,
					or a children element.
				-
			
			Attributes Element
			
				-
					An attributes element will have the content "Attributes". It may have an
					indefinite number of children, each of which will be an attribute element.
				-
			
			Attribute Element
			
				-
					An attribute element may have any content, and will have a single child which
					may have any content.
					
					The content of both the element and its child will be literal content.
				-
			
			Children Element
				
				-
					A children element will have the content "Children" and may have an indefinite
					number of children, each of which will be an XML element.
				-
			
			Data Element
			
				-
					A data element may have any content other than "Attributes" or "Children", but
					no children.
					
					The content of the element will be literal content.
				-
			
			Literal Content
				
				-
					If literal content starts and ends with a quotation mark, it will represent XML
					content that matches itself where the first and last quotation marks have been
					cropped.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 3 - Miscellaneous Dialects: 2 - CSS Dialect ]#

CSS Dialect
	
	Philosophy
		
		-
			The CSS dialect is a build dialect analogous to CSS.
		-
	
	Principles
	
		Structure
		
			-
				A document written in the CSS dialect shall consist entirely of style elements and
				use elements.
			-
			
			Use Elements
			
				-
					A use element shall have the content "Use" and will have a single child with
					content containing the file path of a ONE+ file which has an element with the
					content "Tags", and an element with the content "CSS".
					
					All of the children of the tags element and all of the children of the css
					element will each have a single child with no children.
				-
			
			Style Elements
			
				-
					A style element shall have the content "Style". A style element must have at
					least one element with the content "Domain", and exactly one element with the
					content "Data".
					
					A domain element's children will specify one of the domains the style block
					effects. A child with no child will represent a tag type. The child of a child
					with the content "On" will represent an ID. The child of a child with the
					content "For" will represent a class. The order in which said children are
					listed dictate their hierarchy.
					
					If an element representing a tag type has content matching the content of a
					child of the tags element in a document referenced by a use element, the
					content of the child of the matching element will be the name of the tag after
					cross compilation. Otherwise, the name of the tag will be the content of the
					element.
					
					The data element's children will each have one child. The content of each child
					of the data element represent an attribute and the content of each of said
					element's children represent the value assigned to the respective attribute.
					
					If a child of the data element has content matching the content of a child of
					the css element in a document referenced by a use element, the content of the
					child of the matching element will be the name of the attribute after cross
					compilation. Otherwise, the name of the tag will be the content of the child of
					the data element.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 3 - Miscellaneous Dialects: 3 - SQL Dialect ]#

SQL Dialect
	
	Philosophy
		
		-
			The SQL dialect is a build dialect analogous to SQL.
		-
	
	Principles
	
		Structure
			
			Use
			
				-
					An element with the content "Use" may have an indefinite number of children,
					each of which with content containing the file path of a ONE+ document.
				-
		
			Statements
			
				-
					A statement is composed of any contiguous set of elements which do not have the
					content "Scope".
				-
			
			Scope
			
				-
					An element with the content "Scope" is equivalent to the statement or
					statements defined by its children.
				-
			
			Splitting
			
				-
					The occurrence of an element with the content "Split" that is nested within an
					element with the content "Scope" denotes that its parent scope element will be
					equivalent to two statements.
					
					The statement preceding the split element will become the first part of each
					statement.
					
					The children of the split element will become the second part of the first
					statement.
					
					The siblings following the split element will become the second part of the
					second statement.
				-
			
			Commands
				
				-
					Commands are elements within a statement that may have children. Whether an
					element is a command or not is dependent on whether its content corresponds to
					an element within a document referenced by a use element.
					
					Each child of a command will be processed as a statement, command, or literal
					depending on its content, and the content of a command will determine how the
					processed forms of its children are formatted during cross compilation.
				-
			
			Literals
			
				-
					Literals are elements which occur within statements but are not commands.
					
					Literals may not have children.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 2 - Dialects: 1 - ONE: 2 - Build Dialect: 3 - Miscellaneous Dialects: 4 - CSV Dialect ]#

CSV Dialect

	Philosophy
	
		-
			The CSV dialect is a build dialect analogous to CSV.
		-
	
	Principles
	
		Structure
		
			-
				Every element in the CSV dialect contains the content "Row". Each row element may
				have any number of children as long as it has at least one. Each child of a row
				element may have any content but may have no children.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE ]#

Standard Kaeon ACE
	
	Philosophy
		
		-
			Standard Kaeon ACE is a specific set of component elements for the Kaeon ACE that
			establishes a game development framework.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 1 - Subcomponent: 1 - Vector 3 ]#

Vector 3
	
	Philosophy
		
		-
			A vector 3 element is an ACE element that represents a three dimensional vector.
			
			It must have the content "Vector 3".
		-
	
	Principles
		
		Children
			
			-
				The element must have three children with the content "X", "Y", and "Z"
				respectively. Each child will itself have a single child with a number as said
				child's content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 1 - Subcomponent: 2 - Color ]#

Color

	Philosophy
	
		-
			A color element is an ACE element that represents an alpha-red-green-blue color.
			
			It must have the content "Color".
		-
	
	Principles
		
		Children
		
			-
				The element must have children with the content "Alpha", "Red", "Green", and "Blue"
				respectively, each of which must have a child with a number between zero and one as
				said child's content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 1 - Subcomponent: 3 - Texture ]#

Texture

	Philosophy
	
		-
			A texture element is an ACE element that represents a texture map.
			
			It must have the content "Texture".
		-
	
	Principles
		
		Data Section
		
			-
				The element must have a single child with the file path to an image or texture file
				as its content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 1 - Subcomponent: 4 - Vertex ]#

Vertex

	Philosophy
	
		-
			A vertex element is an ACE element that represents a vertex of a polygon.
			
			It must have the content "Vertex".
		-
	
	Principles
		
		Children
		
			-
				The element must have a child with the content "Position", and may also have a
				child with the content "Normal", as well as a child with the content "Texture". All
				of the aforementioned children must have a single vector 3 element as its child.

				The element may also have one color element as its child.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 1 - Subcomponent: 5 - Polygon ]#

Polygon

	Philosophy
	
		-
			A polygon element is an ACE element that represents a polygon in a mesh.
			
			It must have the content "Polygon".
		-
	
	Principles
		
		Children
			
			-
				The element must have a child with the content "Indexes", which may have an
				indefinite number of children, each of which have an integer number as their
				content.
				
				The element may also have one color element as a child.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 1 - Tag ]#

Tag
	
	Philosophy
	
		-
			A tag element is a Kaeon ACE component that represents a tag identifier.

			It must have the content "Tag".
		-
	
	Principles
		
		Children
			
			-
				The element must have a single element as its child, the content of which shall
				specify the tag that the element represents.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 10 - Audio ]#

Audio

	Philosophy
	
		-
			A audio element is an ACE element that represents an audio clip.
			
			It must have the content "audio".
		-
	
	Principles
		
		Children
		
			-
				The element must have a single child with the file path to an audio file as its
				content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 11 - Conduit ]#

Conduit

	Philosophy
	
		-
			A conduit element is a Kaeon ACE component wherein the children of the element are
			periodically updated by the host environment based on its type.

			It must have the content "Conduit".
		-
	
	Principles
		
		Children
		
			-
				The element must have two children, one with the content "Type", and the other with
				the content "Port". The type element must have a child with either "Keyboard" or
				"Mouse" as its content, and the port element must have no children.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 12 - Loadable ]#

Loadable

	Philosophy
	
		-
			A loadable is a Kaeon ACE component that represents a loadable resource.

			It must have the content "Loadable".
		-
	
	Principles
		
		Children
		
			-
				The element must have two children, one with the content "Type" and the other with
				the content "Source".

				The type element must have a child with content specifying the type of loadable
				that the loadable element represents, and the source element must have a child with
				content specifying the file path of the resource that the loadable element
				represents.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 12 - Loadable: 1 - Types: 1 - Model ]#

Model
	
	Philosophy
		
		-
			A model is a type of loadable element that represents a pre-defined meshe, rig, or
			colliders.

			The type child of the loadable element must have a child with the content "Model".
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 12 - Loadable: 1 - Types: 2 - Height Map ]#

Height Map
	
	Philosophy
		
		-
			A height map is a type of loadable element that represents the mesh and collider of a
			terrain height map.

			The type child of the loadable element must have a child with the content "Height Map".
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 12 - Loadable: 1 - Types: 3 - Skybox ]#

Skybox
	
	Philosophy
		
		-
			A skybox is a type of loadable represents the mesh and texture of a skybox.

			The type child of the loadable element must have a child with the content "Skybox".
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 2 - Field ]#

Field
	
	Philosophy
		
		-
			A field element is a Kaeon ACE component that represents a field of data with an alias
			and content.

			It must have the content "Field".
		-
	
	Principles
		
		Children
		
			-
				The element must have one child, where the content of said child shall represent
				the alias of the field. Said child must itself have one child, the content of which
				shall represent the content of the field.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 3 - Script ]#

Script
	
	Philosophy
		
		-
			A script element is a Kaeon ACE component that represents a script attached to the
			entity it belongs to.

			It must have the content "Script".
		-
	
	Principles
		
		Children
		
			-
				The element may have any number of children, each of which may have as their
				content "On Start", "On Update", "On Activate", "On Deactivate", or "On Destroy",
				and the children of each of said children shall constitute a Kaeon FUSION script.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 3 - Script: 1 - ACE Interface ]#

ACE Interface

	Philosophy
		
		-
			The ACE interface is a Kaeon FUSION interface that allows Kaeon FUSION code to navigate
			manipulate an ACE document.

			It has the alias "ACE".
		-
	
	Principles
		
		Commands
			
			Get Document
			
				-
					The get document command contains the content "Get Document", and returns the
					ACE document that the script it belongs to is acting on in ONE list form.
				-
			
			Set Document
			
				-
					The set document command contains the content "Set Document", and has one child
					that returns an element in ONE list form, and sets the ACE document that the
					script it belongs to is acting on to the element returned by its child.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 4 - Mesh ]#

Mesh

	Philosophy
	
		-
			A mesh element is a Kaeon ACE component that represents a collection of polygons
			attached to the entity it belongs to.

			It must have the content "Mesh".
		-
	
	Principles
		
		Children
		
			-
				The element may have one or both of the geometry element and a color element.
				
				The geometry element, if present, shall have the content "Geometry", and may have
				an indefinite number of vertex elements and polygon elements as children. The order
				in which a vertex or polygon element is listed relative to other elements of the
				same type shall be its index.

				The element must also have as a child an element with the content "Type", which
				itself must have a child with the content "3D", "2D", "2D Aspect Off", or "2D
				Absolute".
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 5 - Collider ]#

Collider

	Philosophy
		
		-
			A collider element is a Kaeon ACE component that represents a rigid body attached to
			the entity it belongs to.

			It must have the content "Collider".
		-
	
	Principles
		
		Children
		
			-
				The element may have a mesh element as a child, and must have a child with the
				content "Type", which must have a child with the content "Mesh" or "Sphere".
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 6 - Force ]#

Force

	Philosophy
	
		-
			A force element is a Kaeon ACE component that represents a force attached to the entity
			it belongs to.

			It must have the content "Force".
		-
	
	Principles
			
		Children
		
			-
				The element must have a vector 3 element as a child.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 7 - Transform ]#

Transform

	Philosophy
		
		-
			A transform element is a Kaeon ACE component that represents a transformation attached
			to the entity it belongs to.

			It must have the content "Transform".
		-
	
	Principles
		
		Children
		
			-
				The element must have a vector 3 element as a child, and must also have a child
				with the content "Type", which itself must have a child with the content
				"Translation", "Rotation", or "Scale".
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 8 - Camera ]#

Camera
	
	Philosophy
	
		-
			A camera element is a Kaeon ACE component that represents a camera attached to the
			entity it belongs to.

			It must have the content "Camera".
		-
	
	Principles
		
		Children
		
			-
				The element may have as children an indefinite number of transform elements, which
				will apply in order.
				
				The element may also have a child with the content "FOV", which itself shall have a
				child with a number as its content. If the FOV is not specified, it will be set to
				a default value.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 9 - Effect ]#

Effect

	Philosophy
	
		-
			An effect element is a Kaeon ACE component that represents a graphical effect attached
			to the entity it belongs to.

			It must have the content "Effect".
		-
	
	Principles
		
		Children
		
			-
				The element may have an indefinite number of transform elements as children, and up
				to one color element.

				The element must have a child with the content "Type", which itself must have a
				child with the content "Background Color", "Light", or "Fog". The element may also
				have a child with the content "Intensity", which shall have a single child that has
				a number as its content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 1 - Objects: 2 - Component: 9 - Properties ]#

Properties

	Philosophy
	
		-
			A properties element is a Kaeon ACE component that represents properties of the entity
			it belongs to.

			It must have the content "Properties".
		-
	
	Principles
		
		Children
		
			-
				The element may have one or both of children with the content "Active" or
				"Destroyed", each of which, if present, must have a child with either "True" or
				"False" as its content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 2 - Directives: 1 - Frame Properties ]#

Frame Properties

	Philosophy
		
		-
			A frame properties element is a Kaeon ACE component that represents the frame
			properties of the GUI of its host environment.

			It must have the content "Frame Properties".
		-
	
	Principles
		
		Children

			-
				The element may have a child with the content fullscreen.

				The element may also have a child with the content "Icon", which if present shall
				have a child containing the file path to an image as its content.

				The element may also have a child with the content "Title", which if present shall
				have a child containing any string.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 1 - Standard Kaeon ACE: 1 - Components: 2 - Directives: 2 - Tick Rate ]#

Tick Rate

	Philosophy
		
		-
			A tick rate element is a Kaeon ACE component that represents the tick rate of the
			script processor of its host environment.

			It must have the content "Tick Rate".
		-
	
	Principles
		
		Children
		
			-
				The element must have a single child that contains a number as its content.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 2 - Kaeon ACE Interfaces: 1 - FUSION: 1 - Kaeon ACE Interface ]#

Kaeon ACE FUSION Interface

	Philosophy

		-
			The Kaeon ACE FUSION interface is a Kaeon FUSION interface with the alias "Kaeon ACE"
			that, upon completion of the execution of the script into which it is incorporated,
			causes said script to be interpreted as a Kaeon ACE document where the Philosopher's
			Atlas that hosts the FUSION interpreter is repurposed to serve as a Kaeon ACE
			interface, with the core of the FUSION interpreter becoming the core of said interface.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 2 - Kaeon ACE Interfaces: 1 - FUSION: 2 - Module Interfaces ]#

Kaeon ACE Module Interface

	Philosophy

		-
			A Kaeon ACE module interface is a type of Kaeon FUSION interface that attaches Kaeon
			ACE modules to the Philosopher's Atlas of the FUSION interpreter, which is assumed to
			be running in an environment capable of hosting a Kaeon ACE application.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 2 - Kaeon ACE Interfaces: 1 - FUSION: 2 - Module Interfaces: 1 - Standard ]#

Kaeon ACE Standard Interface

	Philosophy

		-
			The Kaeon ACE standard interface is a Kaeon FUSION module interface with the alias
			"Kaeon ACE Standard", that contains all of the Kaeon ACE modules required by the
			standard Kaeon ACE framework.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 2 - Kaeon ACE Interfaces: 2 - ACE: 1 - Babylon ]#

Kaeon ACE Babylon Interface

	Philosophy

		-
			The Kaeon ACE Babylon interface is a JavaScript based Kaeon ACE Interface that renders
			Kaeon ACE content to the babylon.js engine.
		-

	Principles

		Hosting

			-
				Being JS based, Kaeon ACE applications running on the Kaeon ACE Babylon interface
				my run in any browser environment, and there may also be specialized shadow hosts
				for such applications.

				Due to restrictions on audio autoplay, the Kaeon ACE Babylon interface should show
				a start screen with a "Start" button that the user must manually click before the
				application launches.

				Additionally, the Kaeon ACE Babylon interface should check whether the device it is
				running on offers VR support, and provide an option to launch it if the
				functionality is available.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 3 - Kaeon ACE Metagame ]#

Kaeon ACE Metagame
	
	Philosophy
	
		-
			The Kaeon ACE Metagame is a convention that establishes a type of ACE element that
			can store save data for a game in a user's library, where such an element has the
			content "Kaeon ACE Meta" and two children, one with the content "Source" which has a
			child containing the name of a given game, and one with the content "Data" which may
			have an indefinite number of children each containing the name of a save file as its
			content having a child with the content of said save file as its content.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 3 - Kaeon ACE Modules: 4 - Kaeon ACE Valhalla ]#

Kaeon ACE Valhalla

	Philosophy

		-
			The Kaeon ACE Valhalla framework is a set of defined Kaeon ACE entities composed of the
			components provided by the standard Kaeon ACE modules which serves to establish a
			platform for open-universe physics-based games and simulations, with other
			miscellaneous utilities.
		-

	Principles
		
		True Flight

			-
				The Kaeon ACE Valhalla framework provides utilities for creating games that utilize
				the true flight mechanic.

				These utilities allow for both first and third person gameplay.
			-

		Dynamic AI

			-
				The Kaeon ACE Valhalla framework provides utilities for guiding dynamic NPC
				behavior powered by machine learning models as opposed to decision trees.

				It also provides utilities for engaging verbally with NPCs via speech recognition
				and speech synthesis technology.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs ]#

Standard APIs

	Philosophy

		-
			The standard APIs are a set of specifications for utility modules that may be
			implemented in any language unless stated otherwise in such a specification.
		-

	Principles

		Kaeon Suite

			-
				The Kaeon Suite is a module that contains all of the standard APIs available for a
				given language.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs: 1 - APIs: 1 - Common: 1 - ONE Suite ]#

ONE Suite API

	Philosophy

		-
			The ONE Suite API is an API that may be used for processing ONE, ONE+, and Kaeon FUSION
			in various languages, and for using the universal preprocessor.
		-

	Principles

		Functions

			Preprocess

				-
					The preprocess function shall take a string as an argument, and shall execute
					any universal preprocessor directives in said string, and shall return the
					resulting string.
				-

			Parse

				-
					The parse function shall take any ONE or ONE+ string as an argument and shall
					return the content of said string in ONE list form, and shall utilize the
					universal preprocessor when parsing.
				-

			Write

				-
					The write function shall take a list representing a ONE document in ONE list
					form, and shall return the content of the document as a ONE document string.
				-

			Process

				-
					The process function shall take a ONE document in either the form of a ONE+
					string which may have universal preprocessor directives or in ONE list form as
					its first argument, and may optionally take an object representing a saved
					state of a Kaeon FUSION interpreter, which may be an empty object.

					If it recieved an interpreter state as an argument, it shall load said state
					into a Kaeon FUSION interpreter, and if not shall load a default Kaeon FUSION
					interpreter, and then shall use said interpreter to process the recieved ONE
					document as Kaeon FUSION code.

					After running the Kaeon FUSION script, it shall return the return value of the
					Kaeon FUSION script.
				-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs: 1 - APIs: 1 - Common: 2 - IO ]#

IO API

	Philosophy

		-
			The IO API is an api for general purpose IO tasks involving the console and the file
			system.
		-

	Principles

		Open

			-
				The open function takes a string specifying either a file path or URL and returns
				the string content from said location.
			-

		Save

			-
				The save function takes a string specifying the content of a file as its first
				argument and a string specifying a file path as its second argument, and writes the
				content to a new file at said path.
			-

		Get Input

			-
				The get input function takes a string specifying a user prompt, opens a user prompt
				displaying said string, and then returns whatever text the user enters.
			-

		Run

			-
				The run function takes a string specifying a command line operation, and executes
				said command.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs: 1 - APIs: 1 - Common: 3 - Tokenizer ]#

Tokenizer

	Philosophy

		-
			The tokenizer API provides the user with a function that can automatically tokenize any
			text.
		-

	Principles

		Tokenize

			-
				The tokenize function takes a string as its first argument and a list of strings
				representing tokens as its second argument, tokenizes the first string based on the
				specified tokens, in order of the longest tokens to the shortest, and returns the
				tokenized string as a list of strings.
			-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs: 1 - APIs: 1 - Common: 4 - Server ]#

Server API

	-
		The server API provides several functions for running an HTTP or HTTPS server.
	-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 4 - Standard APIs: 1 - APIs: 2 - JavaScript: 1 - UI ]#

UI API

	Philosophy

		-
			The UI API is a JavaScript API that provides several functions for manual DOM
			manipulation.
		-

#[ Kaeon United Specification: 2 - Suite: 3 - Kaeon Series: 5 - Applications: 1 - Kaeon Origin ]#

Kaeon Origin

	Philosophy
	
		-
			Kaeon Origin is an online in-browser default virtual system.
		-

	Principles

		Virtual System Specification

			-
				A URL argument may be passed to Kaeon Origin specifying a path containing a file
				with additional virtual system commands to incorporate into the virtual system.
			-

		Startup Processes Specification

			-
				A URL argument may be passed to Kaeon Origin specifying a path containing a file
				specifying a sequence of virtual system commands to execute upon startup.
			-

		Shell Specification

			-
				The shell in use may be specified as a URL argument.

				If no shell is specified, Kaeon Origin shall use the default shell for the default
				virtual system.
			-

		File Access

			-
				By default, Kaeon Origin's virtual file system shall use a disk defined by a file
				JSON object stored in a browser cookie with the alias "Origin", and shall also
				allow the use of HTTP and HTTPS via disks with the aliases "HTTP" and "HTTPS"
				respectively, and shall include utilities for adding and removing disks from the
				file system.

				Additionally, Kaeon Origin shall have a optional complimentary plugin which, if
				installed, shall allow the browser to access the local system directly and for the
				virtual file system to use it as a disk, and for the virtual system to execute
				commands directly on it.
			-

		Kaeon United

			-
				Kaeon Origin's virtual system shall provide access to the CLI functionality of
				Kaeon United.
			-